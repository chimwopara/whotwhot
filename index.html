<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nigerian Whot Game - Multiplayer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Tinos:wght@700&family=Dancing+Script:wght@700&display=swap" rel="stylesheet">
    <style>
        * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        body {
            font-family: 'Poppins', sans-serif;
            touch-action: manipulation;
        }
        .card {
            width: 120px;
            height: 180px;
            border: 1px solid #888;
            border-radius: 10px;
            background-color: #f8f8f8;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            color: #8C1C13;
            font-family: 'Tinos', serif;
            font-weight: 700;
        }
        .card.dragging {
            opacity: 0.3;
            transform: rotate(5deg) scale(0.9) !important;
            z-index: 1000 !important;
            pointer-events: none;
        }
        .drop-zone {
            border: 2px dashed #4ade80 !important;
            background-color: rgba(74, 222, 128, 0.1) !important;
            border-radius: 8px !important;
        }
        .card-back {
            background-color: #8C1C13;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 1rem;
        }
        .whot-text-back {
            font-family: 'Dancing Script', cursive;
            font-size: 34px;
            color: white;
            line-height: 1;
        }
        .card-symbol {
            width: 70px;
            height: 70px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .corner {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 24px;
            line-height: 1;
        }
        .corner-shape {
            width: 14px;
            height: 14px;
        }
        .top-left { top: 10px; left: 10px; }
        .bottom-right { bottom: 10px; right: 10px; transform: rotate(180deg); }
        .whot-card-center {
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .whot-text {
            font-family: 'Dancing Script', cursive;
            font-size: 38px;
            line-height: 1;
        }
        .player-hand-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 220px;
            position: relative;
        }
        .player-hand-container .card, #right-hand .card {
            position: absolute;
            transition: transform 0.3s ease;
        }
        .computer-player-profile {
            position: relative;
            width: 140px;
            height: 220px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 8px;
            border-radius: 8px;
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        .computer-player-profile.active-turn {
            background-color: #ca8a04;
            box-shadow: 0 0 15px #ca8a04;
        }
        .bot-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid white;
            object-fit: cover;
            background-color: #4a5568;
        }
        .card-stack-container {
            position: relative;
            width: 120px;
            height: 180px;
        }
        .card-stack-container .card {
            position: absolute;
            top: 0;
            left: 0;
            cursor: default;
        }
        .card-stack-container .card:hover {
            transform: none;
        }
        #game-board {
            perspective: 1000px;
        }
        #shape-modal {
            transition: opacity 0.3s ease-in-out;
        }
        .shape-option {
            transition: transform 0.2s;
        }
        .shape-option:hover {
            transform: scale(1.1);
        }
        .toast {
            animation: fade-in-out 3s forwards;
        }
        @keyframes fade-in-out {
            0% { opacity: 0; transform: translateY(20px); }
            15% { opacity: 1; transform: translateY(0); }
            85% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        .drawing-card {
            position: fixed;
            z-index: 100;
            transition: transform 0.4s ease-in-out, opacity 0.4s;
        }
        .push-button {
            background-color: #ca8a04;
            color: white;
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .push-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .push-button:disabled:hover {
            background-color: #ca8a04;
        }
        .card.border-4 {
            border-width: 2px;
        }
        .card.border-2 {
            border-width: 1px;
        }
        .border-yellow-400 {
            border-color: #facc15;
        }
        .border-blue-400 {
            border-color: #60a5fa;
        }
        .bg-yellow-400 {
            background-color: #facc15;
        }
        .text-black {
            color: #000;
        }
        @media (max-width: 640px) {
            .card.border-4 {
                border-width: 1px;
            }
            .card.border-2 {
                border-width: 1px;
            }
            .absolute.-top-2.-right-2 {
                top: -4px;
                right: -4px;
                width: 12px;
                height: 12px;
                font-size: 8px;
            }
        }
        .eliminated {
            opacity: 0.5;
            filter: grayscale(1);
        }
        #rotate-device-overlay {
            display: none;
        }
        @media (max-width: 768px) and (orientation: portrait) {
            #game-container, #setup-screen, #multiplayer-setup, #lobby-screen {
                display: none !important;
            }
            #rotate-device-overlay {
                display: flex;
            }
        }
        @media (max-width: 1024px) {
            .card {
                width: 70px;
                height: 105px;
            }
            .corner {
                font-size: 14px;
            }
            .whot-text {
                font-size: 20px;
            }
            .whot-text-back {
                font-size: 24px;
            }
            .card-symbol {
                width: 35px;
                height: 35px;
            }
            .corner-shape {
                width: 10px;
                height: 10px;
            }
            .player-hand-container {
                min-height: 120px;
            }
            .computer-player-profile {
                width: 80px;
                height: 140px;
                gap: 4px;
                padding: 4px;
            }
            .bot-avatar {
                width: 30px;
                height: 30px;
            }
            .card-stack-container {
                width: 70px;
                height: 105px;
            }
            #game-board {
                gap: 0.5rem;
                margin: 0.5rem 0;
            }
            #discard-pile {
                width: 150px !important;
                height: 105px !important;
            }
            #game-status {
                font-size: 1rem;
                width: 20px;
            }
            .push-button {
                padding: 4px 8px;
                font-size: 12px;
            }
            .text-base {
                font-size: 12px;
            }
            #computer-players-area {
                gap: 0.5rem;
            }
            body {
                padding: 0.5rem;
            }
            #game-container {
                gap: 0.5rem;
            }
            .w-full.p-2 {
                padding: 0.5rem;
            }
            .grid-cols-2 {
                gap: 0.5rem;
            }
        }
        /* Mobile menu optimizations */
        @media (max-width: 768px) {
            .max-w-md {
                max-width: 90vw;
            }
            .p-8 {
                padding: 1rem;
            }
            .text-4xl {
                font-size: 2rem;
            }
            .text-3xl {
                font-size: 1.5rem;
            }
            .text-2xl {
                font-size: 1.25rem;
            }
            .text-xl {
                font-size: 1rem;
            }
            .py-3 {
                padding-top: 0.5rem;
                padding-bottom: 0.5rem;
            }
            .mb-8 {
                margin-bottom: 1rem;
            }
            .mb-6 {
                margin-bottom: 0.75rem;
            }
            .gap-4 {
                gap: 0.5rem;
            }
        }

        /* Landscape mobile optimizations */
        @media (max-width: 896px) and (orientation: landscape) {
            .fixed.inset-0 {
                padding: 0.5rem;
            }
            .max-w-md {
                max-width: 95vw;
                max-height: 90vh;
            }
            .p-8 {
                padding: 0.75rem;
            }
            .text-4xl {
                font-size: 1.5rem;
                margin-bottom: 0.5rem;
            }
            .text-3xl {
                font-size: 1.25rem;
                margin-bottom: 0.25rem;
            }
            .text-2xl {
                font-size: 1.125rem;
            }
            .text-xl {
                font-size: 0.875rem;
            }
            .py-3 {
                padding-top: 0.375rem;
                padding-bottom: 0.375rem;
            }
            .px-4 {
                padding-left: 0.75rem;
                padding-right: 0.75rem;
            }
            .mb-8 {
                margin-bottom: 0.5rem;
            }
            .mb-6 {
                margin-bottom: 0.375rem;
            }
            .mb-4 {
                margin-bottom: 0.25rem;
            }
            .mb-2 {
                margin-bottom: 0.125rem;
            }
            .gap-4 {
                gap: 0.25rem;
            }
            .space-y-2 > * + * {
                margin-top: 0.125rem;
            }
            
            /* Compact lobby layout */
            #lobby-screen .bg-gray-800 {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 0.5rem;
                align-items: start;
            }
            #lobby-screen h2 {
                grid-column: 1 / -1;
                text-align: center;
                margin-bottom: 0.25rem;
            }
            #lobby-screen .mb-4:nth-child(2),
            #lobby-screen .mb-4:nth-child(3) {
                margin-bottom: 0.25rem;
            }
            #lobby-screen .flex.gap-4,
            #lobby-screen #waiting-message {
                grid-column: 1 / -1;
            }
            
            /* Compact ready check layout */
            #ready-check-screen .bg-gray-800 {
                max-height: 85vh;
                overflow-y: auto;
            }
            #ready-check-screen h2 {
                font-size: 1.125rem;
                margin-bottom: 0.25rem;
            }
            #ready-check-screen p {
                font-size: 0.875rem;
                margin-bottom: 0.375rem;
            }
            
            /* Game mode cards side by side */
            #game-mode-screen .flex.flex-col {
                flex-direction: row;
                gap: 0.5rem;
            }
            #game-mode-screen .bg-gray-700 {
                padding: 0.5rem;
                flex: 1;
            }
            #game-mode-screen h3 {
                font-size: 0.875rem;
                margin-bottom: 0.25rem;
            }
            #game-mode-screen .text-sm {
                font-size: 0.75rem;
            }
        }

        /* Extra small landscape (iPhone SE, etc.) */
        @media (max-width: 667px) and (orientation: landscape) and (max-height: 400px) {
            .text-4xl {
                font-size: 1.25rem;
                margin-bottom: 0.25rem;
            }
            .text-3xl {
                font-size: 1rem;
                margin-bottom: 0.125rem;
            }
            .py-3 {
                padding-top: 0.25rem;
                padding-bottom: 0.25rem;
            }
            .p-8 {
                padding: 0.5rem;
            }
            .mb-6 {
                margin-bottom: 0.25rem;
            }
            .gap-4 {
                gap: 0.125rem;
            }
            
            /* Ultra compact lobby */
            #lobby-screen .bg-gray-800 {
                font-size: 0.75rem;
            }
            #lobby-players {
                max-height: 60px;
                overflow-y: auto;
            }
            
            /* Horizontal button layout for small screens */
            .flex.flex-col.gap-4 {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }
            .flex.flex-col.gap-4 > button {
                flex: 1;
                min-width: 120px;
            }
        }
        
        @media (max-width: 640px) {
            .card {
                width: 32px;
                height: 48px;
            }
            .corner {
                font-size: 6px;
                top: 1px;
                left: 1px;
            }
            .corner.bottom-right {
                bottom: 1px;
                right: 1px;
            }
            .whot-text {
                font-size: 8px;
            }
            .whot-text-back {
                font-size: 9px;
            }
            .card-symbol {
                width: 14px;
                height: 14px;
            }
            .corner-shape {
                width: 4px;
                height: 4px;
            }
            .player-hand-container {
                min-height: 60px;
            }
            .computer-player-profile {
                width: 35px;
                height: 65px;
                gap: 0;
                padding: 0;
                position: relative;
            }
            .bot-avatar {
                width: 16px;
                height: 16px;
                position: absolute;
                top: 2px;
                right: 2px;
                z-index: 10;
                border: 1px solid white;
            }
            .computer-player-profile .text-base {
                position: absolute;
                bottom: 2px;
                left: 0;
                right: 0;
                text-align: center;
                font-size: 6px;
                color: white;
                background: rgba(0,0,0,0.7);
                padding: 1px;
                border-radius: 2px;
                z-index: 10;
            }
            .card-stack-container {
                width: 32px;
                height: 48px;
            }
            #game-board {
                gap: 0.25rem;
                margin: 0.25rem 0;
            }
            #discard-pile {
                width: 70px !important;
                height: 48px !important;
            }
            #draw-pile {
                width: 32px;
                height: 48px;
            }
            #game-status {
                font-size: 0.625rem;
                width: 8px;
                line-height: 1;
                writing-mode: vertical-rl;
                text-orientation: mixed;
            }
            .push-button {
                padding: 1px 3px;
                font-size: 6px;
                border-radius: 2px;
                line-height: 1.2;
            }
            #computer-players-area {
                gap: 0.25rem;
                margin-bottom: 0.25rem;
                min-height: 70px;
            }
            body {
                padding: 0.125rem;
                padding-top: 0; /* Account for browser UI */
            }
            #game-container {
                gap: 0.125rem;
                min-height: calc(100vh - 0.25rem);
                padding-top: 0.125rem;
            }
            .w-full.p-2 {
                padding: 0.25rem;
            }
            .grid-cols-2 {
                gap: 0.25rem;
            }
            .bg-gray-800\/50 {
                padding: 0.25rem;
                border-radius: 0.25rem;
            }
            .flex.gap-2 {
                gap: 0.125rem;
            }
            #eliminated-bar {
                padding: 0.125rem;
                font-size: 0.75rem;
            }
        }
        
        /* Ultra-compact for very small screens */
        @media (max-width: 480px) {
            .card {
                width: 28px;
                height: 42px;
            }
            .corner {
                font-size: 5px;
            }
            .whot-text {
                font-size: 7px;
            }
            .whot-text-back {
                font-size: 8px;
            }
            .card-symbol {
                width: 12px;
                height: 12px;
            }
            .computer-player-profile {
                width: 30px;
                height: 55px;
            }
            .bot-avatar {
                width: 14px;
                height: 14px;
            }
            .card-stack-container {
                width: 28px;
                height: 42px;
            }
            #discard-pile {
                width: 60px !important;
                height: 42px !important;
            }
            #draw-pile {
                width: 28px;
                height: 42px;
            }
            .player-hand-container {
                min-height: 50px;
            }
            #computer-players-area {
                min-height: 60px;
            }
            .push-button {
                font-size: 5px;
                padding: 1px 2px;
            }
        }
        @media (max-height: 600px) {
            .computer-player-profile {
                height: 100px;
            }
            .player-hand-container {
                min-height: 80px;
            }
            #game-board {
                margin: 0.25rem 0;
            }
            .bg-gray-800\/50 {
                padding: 0.25rem;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center min-h-screen p-4 overflow-hidden">

    <!-- Main Menu -->
    <div id="main-menu" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl text-center w-full max-w-md">
            <h1 class="text-4xl font-bold mb-8" style="font-family: 'Dancing Script', cursive;">Nigerian Whot</h1>
            <div class="flex flex-col gap-4">
                <button id="single-player-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg text-xl transition-colors">
                    Single Player
                </button>
                <button id="multiplayer-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg text-xl transition-colors">
                    Multiplayer
                </button>
            </div>
        </div>
    </div>

    <!-- Single Player Setup -->
    <div id="setup-screen" class="fixed inset-0 bg-black bg-opacity-80 items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl text-center w-full max-w-md">
            <h2 class="text-3xl font-bold mb-2">Single Player</h2>
            <p class="mb-6 text-gray-400">Game Setup</p>
            <div class="mb-6">
                <label class="block mb-2 text-lg font-medium">Select Number of Opponents</label>
                <div class="flex items-center justify-center gap-4">
                    <button id="decrement-players" class="px-4 py-2 bg-amber-600 rounded-md text-xl font-bold">-</button>
                    <span id="player-count-display" class="text-3xl font-bold w-16 text-center">1</span>
                    <button id="increment-players" class="px-4 py-2 bg-amber-600 rounded-md text-xl font-bold">+</button>
                </div>
            </div>
            <div class="flex gap-4">
                <button id="back-to-menu-single" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Back
                </button>
                <button id="start-single-game-btn" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Start Game
                </button>
            </div>
        </div>
    </div>

    <!-- Multiplayer Setup -->
    <div id="multiplayer-setup" class="fixed inset-0 bg-black bg-opacity-80 items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl text-center w-full max-w-md">
            <h2 class="text-3xl font-bold mb-6">Multiplayer</h2>
            <div class="flex flex-col gap-4">
                <input type="text" id="player-name-input" placeholder="Enter your name" class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" maxlength="20">
                <button id="create-game-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Create New Game
                </button>
                <div class="relative">
                    <div class="absolute inset-0 flex items-center">
                        <div class="w-full border-t border-gray-600"></div>
                    </div>
                    <div class="relative flex justify-center text-sm">
                        <span class="px-2 bg-gray-800 text-gray-400">OR</span>
                    </div>
                </div>
                <input type="text" id="game-code-input" placeholder="Enter 6-digit game code" class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 text-center text-xl tracking-wider" maxlength="6">
                <button id="join-game-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Join Game
                </button>
                <button id="back-to-menu-multi" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Back
                </button>
            </div>
        </div>
    </div>

    <!-- Game Mode Selection -->
    <div id="game-mode-screen" class="fixed inset-0 bg-black bg-opacity-80 items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl text-center w-full max-w-md">
            <h2 class="text-3xl font-bold mb-6">Select Game Mode</h2>
            <div class="flex flex-col gap-4">
                <div class="bg-gray-700 p-4 rounded-lg cursor-pointer hover:bg-gray-600 transition-colors" id="counting-mode">
                    <h3 class="text-xl font-bold mb-2">Counting Cards Mode</h3>
                    <p class="text-sm text-gray-300">When someone finishes, count remaining cards. Highest total gets eliminated.</p>
                </div>
                <div class="bg-gray-700 p-4 rounded-lg cursor-pointer hover:bg-gray-600 transition-colors" id="elimination-mode">
                    <h3 class="text-xl font-bold mb-2">Last Standing Mode</h3>
                    <p class="text-sm text-gray-300">Keep playing until last person standing, then they get eliminated. Tournament style!</p>
                </div>
            </div>
            <button id="back-to-setup" class="w-full mt-6 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                Back
            </button>
        </div>
    </div>

    <!-- Multiplayer Lobby -->
    <div id="lobby-screen" class="fixed inset-0 bg-black bg-opacity-80 items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl text-center w-full max-w-md">
            <h2 class="text-3xl font-bold mb-2">Game Lobby</h2>
            <div class="mb-4">
                <p class="text-gray-400 mb-2">Game Code:</p>
                <p id="lobby-game-code" class="text-4xl font-bold tracking-wider text-green-400"></p>
            </div>
            <div class="mb-4">
                <p class="text-gray-400 mb-2">Game Mode:</p>
                <p id="lobby-game-mode" class="text-lg font-semibold text-blue-400"></p>
            </div>
            <div class="mb-6">
                <p class="text-gray-400 mb-2">Players:</p>
                <div id="lobby-players" class="space-y-2"></div>
            </div>
            <div class="flex gap-4">
                <button id="leave-lobby-btn" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Leave
                </button>
                <button id="start-multiplayer-game-btn" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors hidden">
                    Start Game
                </button>
            </div>
            <div id="waiting-message" class="mt-4 text-gray-400">Waiting for host to start game...</div>
        </div>
    </div>

    <!-- Ready Check Screen -->
    <div id="ready-check-screen" class="fixed inset-0 bg-black bg-opacity-80 items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl text-center w-full max-w-md">
            <h2 class="text-3xl font-bold mb-2">Ready Check</h2>
            <p class="text-gray-400 mb-6">Are you ready to start the game?</p>
            <div class="mb-6">
                <div id="ready-players-list" class="space-y-2 mb-4"></div>
            </div>
            <div class="flex gap-4">
                <button id="ready-yes-btn" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    ✓ Ready
                </button>
                <button id="ready-no-btn" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    ✗ Not Ready
                </button>
            </div>
            <div id="waiting-for-ready" class="mt-4 text-gray-400 hidden">Waiting for other players...</div>
        </div>
    </div>

    <div id="game-container" class="w-full max-w-screen-2xl mx-auto flex flex-col items-center justify-between flex-grow hidden">
        <!-- Eliminated Players Bar -->
        <div id="eliminated-bar" class="w-full bg-red-900/50 p-2 text-center text-red-200 hidden">
            <span id="eliminated-text">Eliminated: </span>
        </div>

        <!-- Computer's Area -->
        <div class="w-full">
            <div id="computer-players-area" class="flex flex-wrap justify-center items-start gap-4 md:gap-12"></div>
        </div>

        <!-- Game Board -->
        <div id="game-board" class="flex items-center justify-center gap-4 md:gap-16 my-2 w-full">
            <div id="draw-pile" class="card-stack-container"></div>
            <div id="game-status" class="text-center text-2xl md:text-3xl font-bold leading-tight w-28 md:w-40"></div>
            <div id="discard-pile" class="relative w-[300px] h-[180px]"></div>
        </div>
        
        <!-- Player's Area -->
        <div class="w-full p-2 md:p-4 bg-gray-800/50 rounded-xl">
            <div class="grid grid-cols-2 gap-2 md:gap-4">
                <div class="flex flex-col items-center">
                    <div id="left-hand" class="player-hand-container w-full"></div>
                    <div id="left-push-buttons" class="flex gap-2 mt-2"></div>
                </div>
                <div class="flex flex-col items-center">
                    <div id="right-hand" class="player-hand-container w-full"></div>
                     <div id="right-push-buttons" class="flex gap-2 mt-2"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Rotate Device Overlay -->
    <div id="rotate-device-overlay" class="fixed inset-0 bg-gray-900 z-50 items-center justify-center text-center">
        <div>
            <svg class="w-24 h-24 mx-auto text-white mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 18h.01M8 21h8a2 2 0 002-2V5a2 2 0 00-2-2H8a2 2 0 00-2 2v14a2 2 0 002 2zM5 12h.01M19 12h.01M21 8v.01M21 16v.01M3 8v.01M3 16v.01"></path></svg>
            <h2 class="text-2xl font-bold">Please Rotate Your Device</h2>
            <p class="text-gray-400 mt-2">This game is best played in landscape mode.</p>
        </div>
    </div>

    <!-- Shape Selection Modal -->
    <div id="shape-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50 opacity-0">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl text-center">
            <h2 class="text-2xl font-bold mb-6">Choose a Shape</h2>
            <div id="shape-options" class="flex gap-4"></div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast-container" class="fixed bottom-5 right-5 z-50"></div>

    <!-- Firebase Scripts -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
        import { getDatabase, ref, set, get, onValue, off, push, remove, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAfxzfnXrLtgqBzDZxgI1EMxso8E6iEYf0",
            authDomain: "whotwhotnigeria.firebaseapp.com",
            databaseURL: "https://whotwhotnigeria-default-rtdb.firebaseio.com",
            projectId: "whotwhotnigeria",
            storageBucket: "whotwhotnigeria.firebasestorage.app",
            messagingSenderId: "686057562811",
            appId: "1:686057562811:web:ae26e37cfa2fc2fadd7f9e",
            measurementId: "G-C2SGLN7788"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        
        window.firebase = { database, ref, set, get, onValue, off, push, remove, serverTimestamp };
    </script>

    <script>
        // DOM Elements
        const mainMenu = document.getElementById('main-menu');
        const setupScreen = document.getElementById('setup-screen');
        const multiplayerSetup = document.getElementById('multiplayer-setup');
        const gameModeScreen = document.getElementById('game-mode-screen');
        const lobbyScreen = document.getElementById('lobby-screen');
        const readyCheckScreen = document.getElementById('ready-check-screen');
        const gameContainer = document.getElementById('game-container');

        // Game State
        let gameMode = 'single'; // 'single' or 'multiplayer'
        let gameType = 'counting'; // 'counting' or 'elimination'
        let isHost = false;
        let currentGameId = null;
        let playerId = null;
        let playerName = 'Player';
        let gameStateRef = null;
        let playersRef = null;
        let eliminatedPlayers = [];
        
        // Existing game state variables
        let deck = [];
        let players = [];
        let discardPile = [];
        let drawPile = [];
        let currentPlayerIndex = 0;
        let activeStack = null; 
        let whotRequest = null; 
        let holdOnActive = false;
        let turnsToSkip = 0;
        let draggedCardData = null;
        let isDragging = false;
        let generalMarketState = { active: false, initiator: null, respondedMask: [], playersWhoPlayed: [] };

        const ACTION_CARDS = [1, 2, 5, 8, 14, 20];
        
        const SHAPES_SVG = {
            circle: `<svg viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="11"/></svg>`,
            triangle: `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L1 21h22L12 2z"/></svg>`,
            square: `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M3 3h18v18H3V3z"/></svg>`,
            cross: `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M10 3 H14 V10 H21 V14 H14 V21 H10 V14 H3 V10 H10z"/></svg>`,
            star: `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>`
        };

        const BOT_NAMES = ["Apex", "Bolt", "Cipher", "Dynamo", "Echo", "Fusion", "Glitch", "Helix", "Ion", "Jolt", "Kortex", "Logic"];

        // Firebase helper functions
        function generateGameId() {
            return Math.floor(100000 + Math.random() * 900000).toString();
        }

        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substr(2, 9);
        }

        // Menu Navigation
        document.getElementById('single-player-btn').addEventListener('click', () => {
            gameMode = 'single';
            mainMenu.classList.add('hidden');
            gameModeScreen.classList.remove('hidden');
            gameModeScreen.classList.add('flex');
        });

        document.getElementById('multiplayer-btn').addEventListener('click', () => {
            gameMode = 'multiplayer';
            mainMenu.classList.add('hidden');
            multiplayerSetup.classList.remove('hidden');
            multiplayerSetup.classList.add('flex');
        });

        document.getElementById('back-to-menu-single').addEventListener('click', () => {
            setupScreen.classList.add('hidden');
            setupScreen.classList.remove('flex');
            mainMenu.classList.remove('hidden');
        });

        document.getElementById('back-to-menu-multi').addEventListener('click', () => {
            multiplayerSetup.classList.add('hidden');
            multiplayerSetup.classList.remove('flex');
            mainMenu.classList.remove('hidden');
        });

        document.getElementById('back-to-setup').addEventListener('click', () => {
            gameModeScreen.classList.add('hidden');
            gameModeScreen.classList.remove('flex');
            if (gameMode === 'single') {
                mainMenu.classList.remove('hidden');
            } else {
                multiplayerSetup.classList.remove('hidden');
                multiplayerSetup.classList.add('flex');
            }
        });

        // Game Mode Selection
        document.getElementById('counting-mode').addEventListener('click', () => {
            gameType = 'counting';
            gameModeScreen.classList.add('hidden');
            gameModeScreen.classList.remove('flex');
            if (gameMode === 'single') {
                setupScreen.classList.remove('hidden');
                setupScreen.classList.add('flex');
            } else {
                multiplayerSetup.classList.remove('hidden');
                multiplayerSetup.classList.add('flex');
            }
        });

        document.getElementById('elimination-mode').addEventListener('click', () => {
            gameType = 'elimination';
            gameModeScreen.classList.add('hidden');
            gameModeScreen.classList.remove('flex');
            if (gameMode === 'single') {
                setupScreen.classList.remove('hidden');
                setupScreen.classList.add('flex');
            } else {
                multiplayerSetup.classList.remove('hidden');
                multiplayerSetup.classList.add('flex');
            }
        });

        // Multiplayer Functions
        document.getElementById('create-game-btn').addEventListener('click', async () => {
            const nameInput = document.getElementById('player-name-input');
            if (!nameInput.value.trim()) {
                showToast('Please enter your name', 'error');
                return;
            }
            
            playerName = nameInput.value.trim();
            playerId = generatePlayerId();
            currentGameId = generateGameId();
            isHost = true;

            try {
                // Create game in Firebase
                const gameData = {
                    id: currentGameId,
                    host: playerId,
                    gameType: gameType,
                    status: 'waiting',
                    createdAt: window.firebase.serverTimestamp(),
                    players: {
                        [playerId]: {
                            id: playerId,
                            name: playerName,
                            isHost: true,
                            joinedAt: window.firebase.serverTimestamp()
                        }
                    }
                };

                await window.firebase.set(window.firebase.ref(window.firebase.database, `games/${currentGameId}`), gameData);
                
                multiplayerSetup.classList.add('hidden');
                multiplayerSetup.classList.remove('flex');
                showLobby();
            } catch (error) {
                console.error('Error creating game:', error);
                showToast('Error creating game', 'error');
            }
        });

        document.getElementById('join-game-btn').addEventListener('click', async () => {
            const nameInput = document.getElementById('player-name-input');
            const codeInput = document.getElementById('game-code-input');
            
            if (!nameInput.value.trim()) {
                showToast('Please enter your name', 'error');
                return;
            }
            
            if (!codeInput.value.trim() || codeInput.value.length !== 6) {
                showToast('Please enter a valid 6-digit game code', 'error');
                return;
            }

            playerName = nameInput.value.trim();
            playerId = generatePlayerId();
            currentGameId = codeInput.value.trim();

            try {
                // Check if game exists
                const gameSnapshot = await window.firebase.get(window.firebase.ref(window.firebase.database, `games/${currentGameId}`));
                
                if (!gameSnapshot.exists()) {
                    showToast('Game not found', 'error');
                    return;
                }

                const gameData = gameSnapshot.val();
                
                if (gameData.status !== 'waiting') {
                    showToast('Game already in progress', 'error');
                    return;
                }

                // Join the game
                await window.firebase.set(window.firebase.ref(window.firebase.database, `games/${currentGameId}/players/${playerId}`), {
                    id: playerId,
                    name: playerName,
                    isHost: false,
                    joinedAt: window.firebase.serverTimestamp()
                });

                multiplayerSetup.classList.add('hidden');
                multiplayerSetup.classList.remove('flex');
                showLobby();
            } catch (error) {
                console.error('Error joining game:', error);
                showToast('Error joining game', 'error');
            }
        });

        function showLobby() {
            lobbyScreen.classList.remove('hidden');
            lobbyScreen.classList.add('flex');
            document.getElementById('lobby-game-code').textContent = currentGameId;
            document.getElementById('lobby-game-mode').textContent = gameType === 'counting' ? 'Counting Cards Mode' : 'Last Standing Mode';
            
            if (isHost) {
                document.getElementById('start-multiplayer-game-btn').classList.remove('hidden');
                document.getElementById('waiting-message').classList.add('hidden');
            }

            // Listen for players updates
            playersRef = window.firebase.ref(window.firebase.database, `games/${currentGameId}/players`);
            window.firebase.onValue(playersRef, (snapshot) => {
                const playersData = snapshot.val() || {};
                updateLobbyPlayers(playersData);
            });

            // Listen for game state updates
            gameStateRef = window.firebase.ref(window.firebase.database, `games/${currentGameId}`);
            window.firebase.onValue(gameStateRef, (snapshot) => {
                const gameData = snapshot.val();
                if (gameData) {
                    console.log('Game status:', gameData.status);
                    if (gameData.status === 'ready_check') {
                        showReadyCheck(gameData);
                        // Update ready players list in real time
                        updateReadyPlayersList(gameData.readyPlayers || {}, gameData.players);
                    } else if (gameData.status === 'playing') {
                        console.log('Starting multiplayer game');
                        startMultiplayerGame(gameData);
                    }
                }
            });
        }

        function updateLobbyPlayers(playersData) {
            const lobbyPlayersDiv = document.getElementById('lobby-players');
            lobbyPlayersDiv.innerHTML = '';
            
            Object.values(playersData).forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'bg-gray-700 p-2 rounded flex justify-between items-center';
                playerDiv.innerHTML = `
                    <span>${player.name}</span>
                    <span class="text-sm ${player.isHost ? 'text-yellow-400' : 'text-gray-400'}">${player.isHost ? 'Host' : 'Player'}</span>
                `;
                lobbyPlayersDiv.appendChild(playerDiv);
            });
        }

        document.getElementById('leave-lobby-btn').addEventListener('click', async () => {
            try {
                if (isHost) {
                    // Delete the entire game if host leaves
                    await window.firebase.remove(window.firebase.ref(window.firebase.database, `games/${currentGameId}`));
                } else {
                    // Remove player from game
                    await window.firebase.remove(window.firebase.ref(window.firebase.database, `games/${currentGameId}/players/${playerId}`));
                }
                
                // Clean up listeners
                if (playersRef) window.firebase.off(playersRef);
                if (gameStateRef) window.firebase.off(gameStateRef);
                
                lobbyScreen.classList.add('hidden');
                lobbyScreen.classList.remove('flex');
                multiplayerSetup.classList.remove('hidden');
                multiplayerSetup.classList.add('flex');
                currentGameId = null;
                playerId = null;
                isHost = false;
            } catch (error) {
                console.error('Error leaving lobby:', error);
            }
        });

        document.getElementById('start-multiplayer-game-btn').addEventListener('click', async () => {
            if (!isHost) return;

            try {
                // Get current players
                const playersSnapshot = await window.firebase.get(window.firebase.ref(window.firebase.database, `games/${currentGameId}/players`));
                const playersData = playersSnapshot.val() || {};
                
                if (Object.keys(playersData).length < 2) {
                    showToast('Need at least 2 players to start', 'error');
                    return;
                }

                // Start ready check phase
                const gameUpdate = {
                    status: 'ready_check',
                    startedAt: window.firebase.serverTimestamp(),
                    readyPlayers: {},
                    players: playersData
                };
                
                await window.firebase.set(window.firebase.ref(window.firebase.database, `games/${currentGameId}`), gameUpdate);

            } catch (error) {
                console.error('Error starting ready check:', error);
                showToast('Error starting ready check', 'error');
            }
        });

        function startMultiplayerGame(gameData) {
            console.log('Starting multiplayer game with status:', gameData.status);
            
            if (gameData.status === 'ready_check') {
                showReadyCheck(gameData);
            } else if (gameData.status === 'playing') {
                // Hide all screens and show game
                lobbyScreen.classList.add('hidden');
                lobbyScreen.classList.remove('flex');
                readyCheckScreen.classList.add('hidden');
                readyCheckScreen.classList.remove('flex');
                gameContainer.classList.remove('hidden');
                gameContainer.classList.add('flex');
                
                console.log('Initializing multiplayer game state');
                
                // Initialize the multiplayer game
                initializeMultiplayerGame(gameData);
            }
        }

        function showReadyCheck(gameData) {
            lobbyScreen.classList.add('hidden');
            lobbyScreen.classList.remove('flex');
            readyCheckScreen.classList.remove('hidden');
            readyCheckScreen.classList.add('flex');
            
            // Update ready players list
            updateReadyPlayersList(gameData.readyPlayers || {}, gameData.players);
        }

        function updateReadyPlayersList(readyPlayers, allPlayers) {
            const readyListDiv = document.getElementById('ready-players-list');
            readyListDiv.innerHTML = '';
            
            Object.values(allPlayers).forEach(player => {
                const playerDiv = document.createElement('div');
                const isReady = readyPlayers[player.id];
                const readyIcon = isReady === true ? '✓' : isReady === false ? '✗' : '⏳';
                const readyColor = isReady === true ? 'text-green-400' : isReady === false ? 'text-red-400' : 'text-yellow-400';
                const readyText = isReady === true ? 'Ready' : isReady === false ? 'Not Ready' : 'Waiting...';
                
                playerDiv.className = 'bg-gray-700 p-2 rounded flex justify-between items-center';
                playerDiv.innerHTML = `
                    <span>${player.name}</span>
                    <span class="${readyColor}">${readyIcon} ${readyText}</span>
                `;
                readyListDiv.appendChild(playerDiv);
            });
        }

        // Ready check event listeners
        document.getElementById('ready-yes-btn').addEventListener('click', async () => {
            await setReadyStatus(true);
        });

        document.getElementById('ready-no-btn').addEventListener('click', async () => {
            await setReadyStatus(false);
        });

        async function setReadyStatus(ready) {
            try {
                await window.firebase.set(window.firebase.ref(window.firebase.database, `games/${currentGameId}/readyPlayers/${playerId}`), ready);
                
                document.getElementById('ready-yes-btn').style.display = ready ? 'block' : 'none';
                document.getElementById('ready-no-btn').style.display = ready ? 'none' : 'block';
                document.getElementById('waiting-for-ready').classList.remove('hidden');
                
                // Check if all players are ready
                const gameSnapshot = await window.firebase.get(window.firebase.ref(window.firebase.database, `games/${currentGameId}`));
                const gameData = gameSnapshot.val();
                
                if (isHost && gameData) {
                    checkAllPlayersReady(gameData);
                }
            } catch (error) {
                console.error('Error setting ready status:', error);
            }
        }

        async function checkAllPlayersReady(gameData) {
            const players = gameData.players || {};
            const readyPlayers = gameData.readyPlayers || {};
            
            const allPlayerIds = Object.keys(players);
            const readyCount = allPlayerIds.filter(id => readyPlayers[id] === true).length;
            const notReadyCount = allPlayerIds.filter(id => readyPlayers[id] === false).length;
            
            // If all players have responded
            if (readyCount + notReadyCount === allPlayerIds.length) {
                if (readyCount > notReadyCount) {
                    // Majority ready - start game
                    await startGameAfterReadyCheck(gameData);
                } else if (readyCount === notReadyCount) {
                    // Tie - random selection
                    const randomReady = Math.random() < 0.5;
                    if (randomReady) {
                        showToast('Tie! Randomly starting game...', 'info');
                        setTimeout(() => startGameAfterReadyCheck(gameData), 2000);
                    } else {
                        showToast('Tie! Returning to lobby...', 'info');
                        setTimeout(() => returnToLobby(), 2000);
                    }
                } else {
                    // Majority not ready - return to lobby
                    showToast('Majority not ready. Returning to lobby...', 'info');
                    setTimeout(() => returnToLobby(), 2000);
                }
            }
        }

        async function startGameAfterReadyCheck(gameData) {
            try {
                console.log('Starting game after ready check');
                
                const playerList = Object.values(gameData.players);
                const randomStarterIndex = Math.floor(Math.random() * playerList.length);
                
                // Create initial deck
                const initialDeck = createDeck();
                shuffleDeck(initialDeck);
                
                // Deal cards to players - ALL players get proper hand structure
                const playersWithHands = {};
                playerList.forEach((player) => {
                    playersWithHands[player.id] = {
                        ...player,
                        regularHand: [],
                        actionHand: [],
                        hand: []
                    };
                });
                
                // Deal 6 cards to each player
                let deckCopy = [...initialDeck];
                for (let i = 0; i < 6; i++) {
                    for (const player of playerList) {
                        if (deckCopy.length === 0) break;
                        const card = deckCopy.pop();
                        
                        // All human players get action/regular separation
                        // For this game, we'll treat all players as having both hand types
                        // and let the client decide how to display them
                        if (ACTION_CARDS.includes(card.number)) {
                            playersWithHands[player.id].actionHand.push(card);
                        } else {
                            playersWithHands[player.id].regularHand.push(card);
                        }
                        
                        // Also add to single hand for AI display compatibility
                        playersWithHands[player.id].hand.push(card);
                    }
                }
                
                // Find first non-action card for discard pile
                let firstCardIndex = deckCopy.findIndex(card => !ACTION_CARDS.includes(card.number));
                if (firstCardIndex === -1) { firstCardIndex = 0; }
                const initialDiscardPile = [deckCopy.splice(firstCardIndex, 1)[0]];
                
                const gameUpdate = {
                    status: 'playing',
                    gameState: {
                        currentPlayerIndex: randomStarterIndex,
                        drawPile: deckCopy,
                        discardPile: initialDiscardPile,
                        activeStack: null,
                        whotRequest: null,
                        holdOnActive: false,
                        turnsToSkip: 0,
                        generalMarketState: { active: false, initiator: null, respondedMask: [], playersWhoPlayed: [] },
                        eliminatedPlayers: [],
                        players: playersWithHands
                    },
                    players: gameData.players
                };

                console.log('Updating server with initial game state', gameUpdate.gameState.players);
                await window.firebase.set(window.firebase.ref(window.firebase.database, `games/${currentGameId}`), gameUpdate);
                
            } catch (error) {
                console.error('Error starting game after ready check:', error);
            }
        }

        async function returnToLobby() {
            try {
                await window.firebase.set(window.firebase.ref(window.firebase.database, `games/${currentGameId}/status`), 'waiting');
                await window.firebase.remove(window.firebase.ref(window.firebase.database, `games/${currentGameId}/readyPlayers`));
                
                readyCheckScreen.classList.add('hidden');
                readyCheckScreen.classList.remove('flex');
                showLobby();
            } catch (error) {
                console.error('Error returning to lobby:', error);
            }
        }

        async function initializeMultiplayerGame(gameData) {
            console.log('Initializing multiplayer game', gameData);
            
            // Initialize game state from server
            const serverGameState = gameData.gameState;
            
            // Set up players array
            players = [];
            Object.values(gameData.players).forEach(serverPlayer => {
                const gamePlayer = {
                    id: serverPlayer.id,
                    name: serverPlayer.name,
                    isHuman: serverPlayer.id === playerId,
                    avatar: `https://placehold.co/50x50/4a5568/ffffff?text=${serverPlayer.name.charAt(0)}`
                };
                
                // Set up hands based on server data
                if (serverGameState.players && serverGameState.players[serverPlayer.id]) {
                    const serverPlayerData = serverGameState.players[serverPlayer.id];
                    if (gamePlayer.isHuman) {
                        // Human player - use separate action and regular hands
                        gamePlayer.regularHand = serverPlayerData.regularHand || [];
                        gamePlayer.actionHand = serverPlayerData.actionHand || [];
                    } else {
                        // AI player - use single hand array (combine regular and action hands for AI)
                        gamePlayer.hand = [
                            ...(serverPlayerData.regularHand || []),
                            ...(serverPlayerData.actionHand || [])
                        ];
                    }
                } else {
                    // Fallback initialization
                    if (gamePlayer.isHuman) {
                        gamePlayer.regularHand = [];
                        gamePlayer.actionHand = [];
                    } else {
                        gamePlayer.hand = [];
                    }
                }
                
                players.push(gamePlayer);
            });
            
            console.log('Players initialized with hands:', players.map(p => ({
                name: p.name,
                isHuman: p.isHuman,
                regularCards: p.regularHand ? p.regularHand.length : 0,
                actionCards: p.actionHand ? p.actionHand.length : 0,
                totalCards: p.hand ? p.hand.length : 0
            })));
            
            // Initialize game variables
            drawPile = serverGameState.drawPile || [];
            discardPile = serverGameState.discardPile || [];
            currentPlayerIndex = serverGameState.currentPlayerIndex || 0;
            activeStack = serverGameState.activeStack;
            whotRequest = serverGameState.whotRequest;
            holdOnActive = serverGameState.holdOnActive || false;
            turnsToSkip = serverGameState.turnsToSkip || 0;
            generalMarketState = serverGameState.generalMarketState || { active: false, initiator: null, respondedMask: [], playersWhoPlayed: [] };
            eliminatedPlayers = serverGameState.eliminatedPlayers || [];
            
            console.log('Game state initialized');
            
            // Render the game
            renderGame();
            updateStatusMessage();
            
            // Set up real-time sync
            setupMultiplayerSync();
            
            console.log('Multiplayer game setup complete');
        }

        function setupMultiplayerSync() {
            const gameStateRef = window.firebase.ref(window.firebase.database, `games/${currentGameId}/gameState`);
            window.firebase.onValue(gameStateRef, (snapshot) => {
                const serverGameState = snapshot.val();
                if (serverGameState && gameMode === 'multiplayer') {
                    syncGameState(serverGameState);
                }
            });
        }

        function syncGameState(serverState) {
            console.log('Syncing game state:', serverState);
            
            drawPile = serverState.drawPile || [];
            discardPile = serverState.discardPile || [];
            currentPlayerIndex = serverState.currentPlayerIndex || 0;
            activeStack = serverState.activeStack;
            whotRequest = serverState.whotRequest;
            holdOnActive = serverState.holdOnActive || false;
            turnsToSkip = serverState.turnsToSkip || 0;
            generalMarketState = serverState.generalMarketState || { active: false, initiator: null, respondedMask: [], playersWhoPlayed: [] };
            eliminatedPlayers = serverState.eliminatedPlayers || [];

            // Sync players' hands
            if (serverState.players) {
                players.forEach((player) => {
                    const serverPlayer = serverState.players[player.id];
                    if (serverPlayer) {
                        if (player.isHuman) {
                            player.regularHand = serverPlayer.regularHand || [];
                            player.actionHand = serverPlayer.actionHand || [];
                        } else {
                            player.hand = serverPlayer.hand || [];
                        }
                    }
                });
            }

            renderGame();
            updateStatusMessage();
            
            // Show market status for human player
            if (generalMarketState.active) {
                const humanPlayerIndex = players.findIndex(p => p.isHuman);
                if (humanPlayerIndex !== -1 && !generalMarketState.respondedMask[humanPlayerIndex]) {
                    showToast('General Market! Play a 14 or click draw pile to pass', 'info');
                }
            }

            // Check for win condition
            if (serverState.winner) {
                handleGameEnd(serverState);
            }
        }

        async function updateServerGameState(updates) {
            if (gameMode !== 'multiplayer' || !currentGameId) return;

            try {
                const gameStateRef = window.firebase.ref(window.firebase.database, `games/${currentGameId}/gameState`);
                
                // Prepare player data for server
                const playersData = {};
                players.forEach(player => {
                    playersData[player.id] = {
                        id: player.id,
                        name: player.name,
                        regularHand: player.regularHand || [],
                        actionHand: player.actionHand || [],
                        hand: player.hand || []
                    };
                });

                const fullUpdate = {
                    drawPile,
                    discardPile,
                    currentPlayerIndex,
                    activeStack,
                    whotRequest,
                    holdOnActive,
                    turnsToSkip,
                    generalMarketState,
                    eliminatedPlayers,
                    ...updates,
                    players: playersData,
                    updatedAt: window.firebase.serverTimestamp()
                };

                await window.firebase.set(gameStateRef, fullUpdate);
            } catch (error) {
                console.error('Error updating server game state:', error);
            }
        }

        // Single Player Setup
        const playerCountDisplay = document.getElementById('player-count-display');
        const decrementBtn = document.getElementById('decrement-players');
        const incrementBtn = document.getElementById('increment-players');
        const startSingleGameBtn = document.getElementById('start-single-game-btn');

        decrementBtn.addEventListener('click', () => {
            let count = parseInt(playerCountDisplay.textContent);
            if (count > 1) {
                playerCountDisplay.textContent = count - 1;
            }
        });

        incrementBtn.addEventListener('click', () => {
            let count = parseInt(playerCountDisplay.textContent);
            if (count < 5) {
                playerCountDisplay.textContent = count + 1;
            }
        });

        startSingleGameBtn.addEventListener('click', () => {
            const numBots = parseInt(playerCountDisplay.textContent);
            initializeSinglePlayerGame(numBots);
        });

        function initializeSinglePlayerGame(numBots) {
            players = [];
            players.push({ id: 'human', name: 'You', isHuman: true, regularHand: [], actionHand: [] });
            for (let i = 0; i < numBots; i++) {
                const botName = generateBotName();
                players.push({
                    id: `bot${i+1}`,
                    name: botName,
                    isHuman: false,
                    hand: [],
                    avatar: `https://placehold.co/50x50/4a5568/ffffff?text=${botName.charAt(0)}`
                });
            }
            eliminatedPlayers = [];
            setupScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            gameContainer.classList.add('flex');
            startGame();
        }

        function generateBotName() {
            return BOT_NAMES[Math.floor(Math.random() * BOT_NAMES.length)];
        }

        // Game Logic Functions (Modified for multiplayer support)
        function createDeck() {
            const deck = [];
            const cardDistribution = {
                circle:   [1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 13, 14],
                triangle: [1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 13, 14],
                square:   [1, 2, 3, 5, 7, 10, 11, 13, 14],
                cross:    [1, 2, 3, 5, 7, 10, 11, 13, 14],
                star:     [1, 2, 3, 4, 5, 7, 8]
            };
            for (const shape in cardDistribution) {
                for (const number of cardDistribution[shape]) {
                    deck.push({ shape, number });
                }
            }
            for (let i = 0; i < 5; i++) {
                deck.push({ shape: 'whot', number: 20 });
            }
            return deck;
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        async function startGame() {
            deck = createDeck();
            shuffleDeck(deck);
            discardPile = [];
            drawPile = deck;

            players.forEach(p => {
                if (eliminatedPlayers.includes(players.indexOf(p))) return;
                if (p.isHuman) {
                    p.regularHand = [];
                    p.actionHand = [];
                } else {
                    p.hand = [];
                }
            });

            const existingWinnerMessage = document.querySelector('.winner-message');
            if (existingWinnerMessage) existingWinnerMessage.remove();
            
            updateStatus("Shuffling...");
            renderGame();
            await new Promise(r => setTimeout(r, 800));

            for (let i = 0; i < 6; i++) {
                for(let j = 0; j < players.length; j++) {
                    if (eliminatedPlayers.includes(j)) continue;
                    await dealCardToPlayer(j);
                }
            }
            
            let firstCardIndex = drawPile.findIndex(card => !ACTION_CARDS.includes(card.number));
            if (firstCardIndex === -1) { firstCardIndex = 0; }
            discardPile = [drawPile.splice(firstCardIndex, 1)[0]];
            
            activeStack = null;
            whotRequest = null;
            holdOnActive = false;
            turnsToSkip = 0;
            currentPlayerIndex = findNextActivePlayer(0);
            generalMarketState = { active: false, initiator: null, respondedMask: [], playersWhoPlayed: [] };
            
            renderGame();
            updateStatusMessage();

            if (gameMode === 'multiplayer') {
                await updateServerGameState({});
            }
        }

        function findNextActivePlayer(startIndex) {
            for (let i = 0; i < players.length; i++) {
                const index = (startIndex + i) % players.length;
                if (!eliminatedPlayers.includes(index)) {
                    return index;
                }
            }
            return startIndex; // Fallback
        }

        // Card calculation for counting mode
        function calculateCardValue(card) {
            if (card.number === 20) return 20; // Whot card
            if ([1, 2, 5, 8, 14].includes(card.number)) return 20; // Action cards
            return card.number;
        }

        function calculateHandTotal(player) {
            const allCards = player.isHuman ? 
                [...(player.regularHand || []), ...(player.actionHand || [])] : 
                (player.hand || []);
            return allCards.reduce((total, card) => total + calculateCardValue(card), 0);
        }

        async function checkWinCondition(playerIndex) {
            const player = players[playerIndex];
            const hand = player.isHuman ? [...player.regularHand, ...player.actionHand] : player.hand;
            
            if (hand.length > 0) return false; // Player hasn't won yet

            const activePlayers = players.filter((_, i) => !eliminatedPlayers.includes(i));
            
            if (gameType === 'counting') {
                // Counting Cards Mode
                if (activePlayers.length <= 2) {
                    // Only 2 players left, winner is determined
                    const otherPlayerIndex = players.findIndex((_, i) => i !== playerIndex && !eliminatedPlayers.includes(i));
                    if (otherPlayerIndex !== -1) {
                        await eliminatePlayer(otherPlayerIndex);
                        endGame(player);
                        return true;
                    }
                } else {
                    // More than 2 players, eliminate the one with highest card total
                    let highestTotal = 0;
                    let playerToEliminate = -1;
                    
                    players.forEach((p, i) => {
                        if (i !== playerIndex && !eliminatedPlayers.includes(i)) {
                            const total = calculateHandTotal(p);
                            if (total > highestTotal) {
                                highestTotal = total;
                                playerToEliminate = i;
                            }
                        }
                    });
                    
                    if (playerToEliminate !== -1) {
                        await eliminatePlayer(playerToEliminate);
                        
                        // Check if only one player remains
                        const remainingPlayers = players.filter((_, i) => !eliminatedPlayers.includes(i));
                        if (remainingPlayers.length === 1) {
                            endGame(remainingPlayers[0]);
                            return true;
                        } else {
                            showToast(`${players[playerToEliminate].name} eliminated! Starting new round...`, 'info');
                            setTimeout(() => startGame(), 2000);
                            return true;
                        }
                    }
                }
            } else {
                // Elimination Mode (Last Standing)
                const remainingPlayers = players.filter((_, i) => !eliminatedPlayers.includes(i));
                if (remainingPlayers.length === 1) {
                    // This is the last player standing, eliminate them and end tournament
                    await eliminatePlayer(playerIndex);
                    endGame(null, true); // Tournament winner
                    return true;
                } else {
                    showToast(`${player.name} finished! Starting new round...`, 'success');
                    setTimeout(() => startGame(), 2000);
                    return true;
                }
            }
            
            return false;
        }

        async function eliminatePlayer(playerIndex) {
            if (!eliminatedPlayers.includes(playerIndex)) {
                eliminatedPlayers.push(playerIndex);
                renderEliminatedBar();
                
                if (gameMode === 'multiplayer') {
                    await updateServerGameState({});
                }
            }
        }

        function renderEliminatedBar() {
            const eliminatedBar = document.getElementById('eliminated-bar');
            const eliminatedText = document.getElementById('eliminated-text');
            
            if (eliminatedPlayers.length > 0) {
                const eliminatedNames = eliminatedPlayers.map(i => players[i].name).join(', ');
                eliminatedText.textContent = `Eliminated: ${eliminatedNames}`;
                eliminatedBar.classList.remove('hidden');
            } else {
                eliminatedBar.classList.add('hidden');
            }
        }

        // DOM element references
        const leftHandDiv = document.getElementById('left-hand');
        const rightHandDiv = document.getElementById('right-hand');
        const computerPlayersArea = document.getElementById('computer-players-area');
        const discardPileDiv = document.getElementById('discard-pile');
        const drawPileDiv = document.getElementById('draw-pile');
        const gameStatusDiv = document.getElementById('game-status');
        const shapeModal = document.getElementById('shape-modal');
        const shapeOptionsDiv = document.getElementById('shape-options');
        const leftPushButtonsDiv = document.getElementById('left-push-buttons');
        const rightPushButtonsDiv = document.getElementById('right-push-buttons');

        // Rendering functions
        function createCardElement(card, isFaceUp = true, cardIndex = -1, handName = '') {
            const cardDiv = document.createElement('div');
            if (!isFaceUp) {
                cardDiv.className = 'card card-back';
                cardDiv.innerHTML = `<div class="whot-text-back">Whot</div><div class="whot-text-back" style="transform: rotate(180deg);">Whot</div>`;
                return cardDiv;
            }
            cardDiv.className = 'card';
            
            // Add visual indicator for push edit mode
            if (pushEditMode && card.number === currentPushNumber && handName === currentPushHand) {
                const isSelected = selectedPushCards.some(c => c.cardIndex === cardIndex);
                if (isSelected) {
                    const selectedIndex = selectedPushCards.findIndex(c => c.cardIndex === cardIndex);
                    cardDiv.classList.add('border-4', 'border-yellow-400');
                    cardDiv.style.boxShadow = '0 0 10px #facc15';
                    
                    // Add order number
                    const orderDiv = document.createElement('div');
                    orderDiv.className = 'absolute -top-2 -right-2 bg-yellow-400 text-black rounded-full w-5 h-5 flex items-center justify-center text-xs font-bold z-20';
                    orderDiv.textContent = selectedIndex + 1;
                    cardDiv.appendChild(orderDiv);
                } else if (card.number === currentPushNumber) {
                    cardDiv.classList.add('border-2', 'border-blue-400');
                    cardDiv.style.opacity = '0.8';
                }
            }
            
            const { shape, number } = card;
            if (shape === 'whot') {
                cardDiv.innerHTML = `
                    <div class="corner top-left"><span>20</span></div>
                    <div class="whot-card-center">
                        <div class="whot-text">Whot</div>
                        <div class="whot-text" style="transform: rotate(180deg);">Whot</div>
                    </div>
                    <div class="corner bottom-right"><span>20</span></div>
                `;
            } else {
                const shapeSVG = SHAPES_SVG[shape];
                cardDiv.innerHTML = `
                    <div class="corner top-left">
                        <span>${number}</span>
                        <div class="corner-shape">${shapeSVG}</div>
                    </div>
                    <div class="card-symbol">${shapeSVG}</div>
                    <div class="corner bottom-right">
                        <span>${number}</span>
                        <div class="corner-shape">${shapeSVG}</div>
                    </div>
                `;
            }

            if (handName === 'regular' || handName === 'action') {
                cardDiv.draggable = true;
                cardDiv.dataset.cardIndex = cardIndex;
                cardDiv.dataset.handName = handName;
                
                cardDiv.addEventListener('dragstart', (e) => handleDragStart(e, card, handName, cardIndex));
                cardDiv.addEventListener('dragend', (e) => handleDragEnd(e));
                cardDiv.addEventListener('click', (e) => {
                    if (!isDragging) {
                        if (pushEditMode && card.number === currentPushNumber && handName === currentPushHand) {
                            handlePushCardSelection(card, handName, cardIndex);
                        } else {
                            handleCardClick(card, handName);
                        }
                    }
                });
            }
            
            return cardDiv;
        }
        
        function renderVisualStack(container, cardCount) {
            container.innerHTML = '';
            const maxVisibleCards = 20; 
            const stackSize = Math.min(cardCount, maxVisibleCards);
            if (cardCount > 0) {
                for (let i = 0; i < stackSize; i++) {
                    const cardEl = createCardElement(null, false);
                    cardEl.style.transform = `translateY(${i * 2}px)`;
                    cardEl.style.zIndex = i;
                    container.appendChild(cardEl);
                }
            }
        }

        function renderHand(handArray, containerDiv, handName) {
            containerDiv.innerHTML = '';
            const totalCards = handArray.length;
            
            // Responsive card sizing and overlap
            let cardWidth, overlap;
            if (window.innerWidth <= 480) {
                cardWidth = 28;
                overlap = 8; // Ultra tight for very small screens
            } else if (window.innerWidth <= 640) {
                cardWidth = 32;
                overlap = 10; // Very tight overlap for mobile
            } else if (window.innerWidth <= 1024) {
                cardWidth = 70;
                overlap = 25;
            } else {
                cardWidth = 120;
                overlap = 50;
            }
            
            const totalWidth = cardWidth + (totalCards > 0 ? (totalCards - 1) * overlap : 0);
            
            handArray.forEach((card, i) => {
                const cardEl = createCardElement(card, true, i, handName);
                const xOffset = (i * overlap) - (totalWidth / 2) + (cardWidth / 2);
                cardEl.style.transform = `translateX(${xOffset}px)`;
                cardEl.style.zIndex = i;
                containerDiv.appendChild(cardEl);
            });
        }

        function renderGame() {
            if (players.length === 0) return;
            
            const humanPlayer = players.find(p => p.isHuman);
            if (humanPlayer) {
                humanPlayer.regularHand.sort((a, b) => a.number - b.number);
                humanPlayer.actionHand.sort((a, b) => a.number - b.number);
                
                renderHand(humanPlayer.regularHand, leftHandDiv, 'regular');
                renderHand(humanPlayer.actionHand, rightHandDiv, 'action');
                renderPushButtons();
            }

            computerPlayersArea.innerHTML = '';
            players.forEach((player, index) => {
                if (!player.isHuman) {
                    const profileDiv = document.createElement('div');
                    profileDiv.className = 'computer-player-profile';
                    
                    // Add eliminated styling
                    if (eliminatedPlayers.includes(index)) {
                        profileDiv.classList.add('eliminated');
                    }
                    
                    if (index === currentPlayerIndex && !generalMarketState.active && !eliminatedPlayers.includes(index)) {
                        profileDiv.classList.add('active-turn');
                    }
                    
                    profileDiv.innerHTML = `
                        <img src="${player.avatar}" alt="Bot Avatar" class="bot-avatar">
                        <div class="text-base font-semibold">${player.name}</div>
                    `;
                    
                    const handContainer = document.createElement('div');
                    handContainer.className = 'card-stack-container';
                    renderVisualStack(handContainer, player.hand.length);
                    
                    profileDiv.appendChild(handContainer);
                    computerPlayersArea.appendChild(profileDiv);
                }
            });

            discardPileDiv.innerHTML = '';
            if (discardPile.length > 0) {
                const cardsToShow = discardPile.slice(-5);
                const overlap = 25;
                const cardWidth = window.innerWidth <= 1024 ? 90 : 120;
                const totalWidth = cardWidth + (cardsToShow.length > 1 ? (cardsToShow.length - 1) * overlap : 0);
                
                const containerWidth = discardPileDiv.offsetWidth;
                const groupStartX = (containerWidth - totalWidth) / 2;

                cardsToShow.forEach((card, i) => {
                    const cardEl = createCardElement(card, true);
                    cardEl.style.position = 'absolute';
                    const xOffset = groupStartX + (i * overlap);
                    const yOffset = i * 2;
                    cardEl.style.left = `${xOffset}px`;
                    cardEl.style.top = `${yOffset}px`;
                    cardEl.style.zIndex = i;
                    discardPileDiv.appendChild(cardEl);
                });
            }
           
            renderVisualStack(drawPileDiv, drawPile.length);
            renderEliminatedBar();
            updateStatusMessage();
        }

        // Push card selection state
        let pushEditMode = false;
        let selectedPushCards = [];
        let currentPushNumber = null;
        let currentPushHand = null;

        function renderPushButtons() {
            leftPushButtonsDiv.innerHTML = '';
            rightPushButtonsDiv.innerHTML = '';

            const humanPlayerIndex = players.findIndex(p => p.isHuman);
            if (currentPlayerIndex !== humanPlayerIndex || eliminatedPlayers.includes(humanPlayerIndex)) return;

            const humanPlayer = players[humanPlayerIndex];

            const findPlayablePushableGroups = (hand) => {
                const counts = hand.reduce((acc, card) => {
                    acc[card.number] = (acc[card.number] || 0) + 1;
                    return acc;
                }, {});
                
                return Object.keys(counts)
                    .map(Number)
                    .filter(num => {
                        const cardsWithNum = hand.filter(c => c.number === num);
                        if (counts[num] < 2) return false;
                        
                        // Use universal ordering to check if push is valid
                        const sortedCards = sortCardsForValidPlay(cardsWithNum);
                        return isCardPlayable(sortedCards[0]);
                    });
            };

            const regularGroups = findPlayablePushableGroups(humanPlayer.regularHand);
            const actionGroups = findPlayablePushableGroups(humanPlayer.actionHand);

            regularGroups.forEach(num => {
                const cardsWithNum = humanPlayer.regularHand.filter(c => c.number === num);
                const sortedCards = sortCardsForValidPlay(cardsWithNum);
                const firstCard = sortedCards[0];
                
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'flex gap-1 items-center';
                
                const button = document.createElement('button');
                button.className = 'push-button';
                button.innerHTML = `Push ${num}s<br><small>(${firstCard.shape} first)</small>`;
                button.onclick = () => playPushGroup(num, 'regular');
                
                const editButton = document.createElement('button');
                editButton.className = 'push-button bg-blue-600 hover:bg-blue-700';
                editButton.innerHTML = '✎';
                editButton.title = 'Customize push order';
                editButton.onclick = () => enterPushEditMode(num, 'regular');
                
                buttonContainer.appendChild(button);
                buttonContainer.appendChild(editButton);
                leftPushButtonsDiv.appendChild(buttonContainer);
            });

            actionGroups.forEach(num => {
                const cardsWithNum = humanPlayer.actionHand.filter(c => c.number === num);
                const sortedCards = sortCardsForValidPlay(cardsWithNum);
                const firstCard = sortedCards[0];
                
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'flex gap-1 items-center';
                
                const button = document.createElement('button');
                button.className = 'push-button';
                button.innerHTML = `Push ${num}s<br><small>(${firstCard.shape} first)</small>`;
                button.onclick = () => playPushGroup(num, 'action');
                
                const editButton = document.createElement('button');
                editButton.className = 'push-button bg-blue-600 hover:bg-blue-700';
                editButton.innerHTML = '✎';
                editButton.title = 'Customize push order';
                editButton.onclick = () => enterPushEditMode(num, 'action');
                
                buttonContainer.appendChild(button);
                buttonContainer.appendChild(editButton);
                rightPushButtonsDiv.appendChild(buttonContainer);
            });
        }

        function enterPushEditMode(number, handName) {
            pushEditMode = true;
            currentPushNumber = number;
            currentPushHand = handName;
            selectedPushCards = [];
            
            showToast('Tap cards to set push order. Tap again to remove.', 'info');
            renderGame();
            renderPushEditControls();
        }

        function renderPushEditControls() {
            if (!pushEditMode) return;
            
            const controlsDiv = currentPushHand === 'regular' ? leftPushButtonsDiv : rightPushButtonsDiv;
            controlsDiv.innerHTML = '';
            
            const controlContainer = document.createElement('div');
            controlContainer.className = 'flex gap-1 items-center';
            
            const cancelButton = document.createElement('button');
            cancelButton.className = 'push-button bg-red-600 hover:bg-red-700';
            cancelButton.innerHTML = 'Cancel';
            cancelButton.onclick = exitPushEditMode;
            
            const pushButton = document.createElement('button');
            pushButton.className = 'push-button bg-green-600 hover:bg-green-700';
            pushButton.innerHTML = `Push ${selectedPushCards.length}`;
            pushButton.disabled = selectedPushCards.length < 2;
            pushButton.onclick = executeCustomPush;
            
            const orderDisplay = document.createElement('div');
            orderDisplay.className = 'text-xs text-white';
            orderDisplay.innerHTML = `Order: ${selectedPushCards.map((_, i) => i + 1).join(', ')}`;
            
            controlContainer.appendChild(cancelButton);
            controlContainer.appendChild(pushButton);
            controlContainer.appendChild(orderDisplay);
            controlsDiv.appendChild(controlContainer);
        }

        function exitPushEditMode() {
            pushEditMode = false;
            currentPushNumber = null;
            currentPushHand = null;
            selectedPushCards = [];
            renderGame();
        }

        function handlePushCardSelection(card, handName, cardIndex) {
            if (!pushEditMode || card.number !== currentPushNumber || handName !== currentPushHand) return;
            
            const humanPlayer = players.find(p => p.isHuman);
            const hand = handName === 'regular' ? humanPlayer.regularHand : humanPlayer.actionHand;
            const actualCard = hand[cardIndex];
            
            // Check if card is already selected
            const existingIndex = selectedPushCards.findIndex(c => 
                c.cardIndex === cardIndex && c.shape === actualCard.shape
            );
            
            if (existingIndex >= 0) {
                // Remove from selection
                selectedPushCards.splice(existingIndex, 1);
            } else {
                // Add to selection
                selectedPushCards.push({
                    card: actualCard,
                    cardIndex: cardIndex,
                    shape: actualCard.shape
                });
            }
            
            renderGame();
            renderPushEditControls();
        }

        async function executeCustomPush() {
            if (selectedPushCards.length < 2 || !pushEditMode) return;
            
            const humanPlayerIndex = players.findIndex(p => p.isHuman);
            const humanPlayer = players[humanPlayerIndex];
            let sourceHand = currentPushHand === 'regular' ? humanPlayer.regularHand : humanPlayer.actionHand;
            
            // Verify first card can be played
            if (!isCardPlayable(selectedPushCards[0].card)) {
                showToast("Cannot push these cards - invalid sequence", "error");
                return;
            }

            // Remove selected cards from hand
            selectedPushCards.forEach(selectedCard => {
                const cardIndex = sourceHand.findIndex(c => 
                    c.shape === selectedCard.shape && c.number === selectedCard.card.number
                );
                if (cardIndex >= 0) {
                    sourceHand.splice(cardIndex, 1);
                }
            });

            // Exit edit mode
            exitPushEditMode();
            
            renderGame();

            // Play cards in selected order
            for (const selectedCard of selectedPushCards) {
                await animateCardPlayFromPosition(selectedCard.card, null, currentPushHand);
                discardPile.push(selectedCard.card);
                renderGame();
                await new Promise(r => setTimeout(r, 100));
            }

            const lastCard = selectedPushCards[selectedPushCards.length - 1].card;
            const numPlayed = selectedPushCards.length;

            // Check win condition first
            const hasWon = await checkWinCondition(humanPlayerIndex);
            if (hasWon) return;

            whotRequest = null;
            if (lastCard.number !== 1) holdOnActive = false;

            if (gameMode === 'multiplayer') {
                await updateServerGameState({});
            }

            // Apply card effects based on last card played
            switch (lastCard.number) {
                case 1: 
                    renderGame();
                    break;
                case 14:
                    // General Market - deal one card to each other player for each 14 played
                    const marketCardsCount = numPlayed;
                    showToast(`General Market! Everyone gets ${marketCardsCount} card${marketCardsCount > 1 ? 's' : ''}`, 'info');
                    
                    for (let i = 0; i < players.length; i++) {
                        if (i !== humanPlayerIndex && !eliminatedPlayers.includes(i)) {
                            for (let j = 0; j < marketCardsCount; j++) {
                                await dealCardToPlayer(i);
                                await new Promise(r => setTimeout(r, 50));
                            }
                        }
                    }
                    
                    renderGame();
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({});
                    }
                    
                    // 14 is like Hold On - player continues their turn after effect
                    return; // Don't call endTurn(), player keeps their turn
                    break;
                case 8: 
                    turnsToSkip = numPlayed;
                    endTurn();
                    break;
                case 20: 
                    if (activeStack) { activeStack = null; }
                    requestShapeFromPlayer();
                    break;
                case 2: case 5: 
                    const penaltyCardNumber = lastCard.number;
                    if (activeStack && activeStack.card === penaltyCardNumber) {
                        activeStack.count += numPlayed;
                    } else {
                        activeStack = { card: penaltyCardNumber, count: numPlayed };
                    }
                    renderGame();
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({});
                    }
                    
                    endTurn();
                    break;
                default:
                    endTurn();
                    break;
            }
        }

        function updateStatus(message) {
             gameStatusDiv.innerHTML = `<div>${message}</div>`;
             gameStatusDiv.style.visibility = 'visible';
        }

        function updateStatusMessage() {
            if (players.length === 0) return;
            gameStatusDiv.innerHTML = '';
            gameStatusDiv.style.visibility = 'hidden';
        }
        
        function showToast(message, type = 'info') {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            let bgColor = 'bg-blue-500';
            if (type === 'error') bgColor = 'bg-red-500';
            if (type === 'success') bgColor = 'bg-green-500';

            toast.className = `toast text-white px-6 py-3 rounded-lg shadow-lg ${bgColor}`;
            toast.textContent = message;
            
            toastContainer.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // Game logic functions (continued)
        async function dealCardToPlayer(playerIndex) {
            if (drawPile.length === 0) {
                if (!reshuffleDiscardPile()) {
                    showToast("Market is empty!", "error");
                    return;
                }
                renderGame();
                await new Promise(r => setTimeout(r, 200));
            }
            
            const player = players[playerIndex];
            const card = drawPile[drawPile.length - 1]; 
            
            if (player.isHuman) {
                const targetDiv = ACTION_CARDS.includes(card.number) ? rightHandDiv : leftHandDiv;
                const hand = ACTION_CARDS.includes(card.number) ? player.actionHand : player.regularHand;
                await dealCard(hand, targetDiv);
            } else {
                const targetDiv = document.querySelector(`#computer-players-area .computer-player-profile:nth-child(${playerIndex}) .card-stack-container`);
                await dealCard(player.hand, targetDiv);
            }
        }

        async function dealCard(handArray, targetDiv) {
            if (drawPile.length === 0) return;

            await animateCardDraw(targetDiv);
            handArray.push(drawPile.pop());

            if (drawPile.length === 0) {
                reshuffleDiscardPile();
            }
            renderGame(); 
        }

        function isCardPlayable(card) {
            if (generalMarketState.active) {
                return card.number === 14;
            }
            if (discardPile.length === 0) return false;
            const topCard = discardPile[discardPile.length - 1];
            if (card.number === 20) return true;
            if (whotRequest) return card.shape === whotRequest.shape;
            if (activeStack) return card.number === activeStack.card || card.number === 20;
            if (holdOnActive) return card.number === 1 || card.shape === topCard.shape;
            return card.shape === topCard.shape || card.number === topCard.number;
        }
        
        function reshuffleDiscardPile() {
            if (discardPile.length <= 1) return false;
            const topCard = discardPile.pop();
            drawPile = [...discardPile];
            shuffleDeck(drawPile);
            discardPile = [topCard];
            return true;
        }

        // Drag and drop handlers
        function handleDragStart(event, card, handName, cardIndex) {
            draggedCardData = { card, handName, cardIndex };
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', 'card'); 
            event.target.classList.add('dragging');
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 1;
            const ctx = canvas.getContext('2d');
            ctx.globalAlpha = 0;
            ctx.fillRect(0, 0, 1, 1);
            event.dataTransfer.setDragImage(canvas, 0, 0);
            setTimeout(() => {
                document.querySelectorAll('#left-hand, #right-hand, #discard-pile').forEach(el => {
                    el.style.pointerEvents = 'auto';
                });
            }, 10);
        }

        function handleDragEnd(event) {
            event.target.classList.remove('dragging');
            document.querySelectorAll('.drop-zone').forEach(el => {
                el.classList.remove('drop-zone');
            });
            draggedCardData = null;
        }

        function handleDragOver(event) {
            if (draggedCardData) {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
            }
        }

        function handleDragEnter(event) {
            if (draggedCardData) {
                event.preventDefault();
                event.currentTarget.classList.add('drop-zone');
            }
        }

        function handleDragLeave(event) {
            const rect = event.currentTarget.getBoundingClientRect();
            const x = event.clientX;
            const y = event.clientY;
            if (x <= rect.left || x >= rect.right || y <= rect.top || y >= rect.bottom) {
                event.currentTarget.classList.remove('drop-zone');
            }
        }

        function handleDropOnHand(event, targetHandName) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.remove('drop-zone');
            if (!draggedCardData) return;

            const { card, handName: sourceHandName } = draggedCardData;
            const humanPlayer = players.find(p => p.isHuman);
            let sourceHand = sourceHandName === 'regular' ? humanPlayer.regularHand : humanPlayer.actionHand;
            let targetHand = targetHandName === 'regular' ? humanPlayer.regularHand : humanPlayer.actionHand;
            
            const cardIndex = sourceHand.findIndex(c => c.shape === card.shape && c.number === card.number);
            if (cardIndex !== -1) {
                const [removedCard] = sourceHand.splice(cardIndex, 1);
                targetHand.push(removedCard);
                renderGame();
            }
        }

        function handleDropOnDiscardPile(event) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.remove('drop-zone');
            if (!draggedCardData) return;

            const { card, handName } = draggedCardData;
            
            const humanPlayerIndex = players.findIndex(p => p.isHuman);
            if ((generalMarketState.active && card.number !== 14) || 
                (!generalMarketState.active && currentPlayerIndex !== humanPlayerIndex)) {
                return;
            }
            
            if (!isCardPlayable(card)) return;

            const humanPlayer = players[humanPlayerIndex];
            let sourceHand = handName === 'regular' ? humanPlayer.regularHand : humanPlayer.actionHand;
            const cardIndex = sourceHand.findIndex(c => c.shape === card.shape && c.number === card.number);
            
            if (cardIndex !== -1) {
                sourceHand.splice(cardIndex, 1);
                renderGame();
                animateCardPlayFromPosition(card, null, handName).then(async () => {
                    if (generalMarketState.active && card.number === 14) {
                        generalMarketState.playersWhoPlayed.push(humanPlayerIndex);
                        generalMarketState.respondedMask[humanPlayerIndex] = true;
                        discardPile.push(card);
                        renderGame();
                        
                        if (gameMode === 'multiplayer') {
                            await updateServerGameState({});
                        }
                        
                        checkIfMarketIsOver();
                    } else {
                        await playCard(card, humanPlayerIndex);
                    }
                });
            }
        }

        function setupDragAndDrop() {
            leftHandDiv.addEventListener('dragover', handleDragOver);
            leftHandDiv.addEventListener('dragenter', handleDragEnter);
            leftHandDiv.addEventListener('dragleave', handleDragLeave);
            leftHandDiv.addEventListener('drop', (e) => handleDropOnHand(e, 'regular'));

            rightHandDiv.addEventListener('dragover', handleDragOver);
            rightHandDiv.addEventListener('dragenter', handleDragEnter);
            rightHandDiv.addEventListener('dragleave', handleDragLeave);
            rightHandDiv.addEventListener('drop', (e) => handleDropOnHand(e, 'action'));

            discardPileDiv.addEventListener('dragover', handleDragOver);
            discardPileDiv.addEventListener('dragenter', (e) => {
                if (draggedCardData && isCardPlayable(draggedCardData.card)) {
                    const humanPlayerIndex = players.findIndex(p => p.isHuman);
                     if (generalMarketState.active || currentPlayerIndex === humanPlayerIndex) {
                        e.preventDefault();
                        e.currentTarget.classList.add('drop-zone');
                    }
                }
            });
            discardPileDiv.addEventListener('dragleave', handleDragLeave);
            discardPileDiv.addEventListener('drop', handleDropOnDiscardPile);
        }

        async function handleCardClick(card, handName) {
            if (isDragging) return;

            const humanPlayerIndex = players.findIndex(p => p.isHuman);

            if (generalMarketState.active) {
                if (card.number === 14) {
                    generalMarketState.playersWhoPlayed.push(humanPlayerIndex);
                    generalMarketState.respondedMask[humanPlayerIndex] = true;

                    const humanPlayer = players[humanPlayerIndex];
                    const hand = handName === 'regular' ? humanPlayer.regularHand : humanPlayer.actionHand;
                    const cardIndex = hand.findIndex(c => c.shape === card.shape && c.number === card.number);
                    if (cardIndex !== -1) hand.splice(cardIndex, 1);
                    
                    await animateCardPlayFromPosition(card, null, handName);
                    discardPile.push(card);
                    renderGame();
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({});
                    }
                    
                    checkIfMarketIsOver();
                }
                return;
            }
            
            if (currentPlayerIndex !== humanPlayerIndex || !isCardPlayable(card)) return;
            
            const humanPlayer = players[humanPlayerIndex];
            let startRect = null; 
            
            const hand = handName === 'regular' ? humanPlayer.regularHand : humanPlayer.actionHand;
            const cardIndex = hand.findIndex(c => c.shape === card.shape && c.number === card.number);
            if (cardIndex !== -1) hand.splice(cardIndex, 1);
            
            renderGame();
            await animateCardPlayFromPosition(card, startRect, handName);
            await playCard(card, humanPlayerIndex);
        }

        // Universal function to sort cards for proper play order
        function sortCardsForValidPlay(cardsToPlay) {
            if (cardsToPlay.length <= 1) return cardsToPlay;
            
            const topCard = discardPile[discardPile.length - 1];
            if (!topCard) return cardsToPlay;
            
            // Sort cards to ensure valid play order
            return cardsToPlay.sort((a, b) => {
                // Priority 1: Cards that match current top card's shape
                if (whotRequest) {
                    // If there's a whot request, prioritize the requested shape
                    if (a.shape === whotRequest.shape && b.shape !== whotRequest.shape) return -1;
                    if (b.shape === whotRequest.shape && a.shape !== whotRequest.shape) return 1;
                } else {
                    // Normal shape matching priority
                    if (a.shape === topCard.shape && b.shape !== topCard.shape) return -1;
                    if (b.shape === topCard.shape && a.shape !== topCard.shape) return 1;
                }
                
                // Priority 2: Whot cards (can be played anytime)
                if (a.number === 20 && b.number !== 20) return -1;
                if (b.number === 20 && a.number !== 20) return 1;
                
                // Priority 3: Cards that match the number
                if (a.number === topCard.number && b.number !== topCard.number) return -1;
                if (b.number === topCard.number && a.number !== topCard.number) return 1;
                
                return 0;
            });
        }

        async function playPushGroup(number, handName) {
            const humanPlayerIndex = players.findIndex(p => p.isHuman);
            if (currentPlayerIndex !== humanPlayerIndex) return;

            const humanPlayer = players[humanPlayerIndex];
            let sourceHand = handName === 'regular' ? humanPlayer.regularHand : humanPlayer.actionHand;
            
            let cardsToPlay = sourceHand.filter(c => c.number === number);
            if (cardsToPlay.length < 2 || !cardsToPlay.some(isCardPlayable)) {
                return;
            }

            // UNIVERSAL LAW: Sort cards to ensure proper play order
            cardsToPlay = sortCardsForValidPlay(cardsToPlay);

            // Verify the first card can be played
            if (!isCardPlayable(cardsToPlay[0])) {
                showToast("Cannot push these cards - invalid sequence", "error");
                return;
            }

            if (handName === 'regular') {
                humanPlayer.regularHand = sourceHand.filter(c => c.number !== number);
            } else {
                humanPlayer.actionHand = sourceHand.filter(c => c.number !== number);
            }
            renderGame();

            for (const card of cardsToPlay) {
                await animateCardPlayFromPosition(card, null, handName);
                discardPile.push(card);
                renderGame();
                await new Promise(r => setTimeout(r, 100));
            }

            const lastCard = cardsToPlay[cardsToPlay.length - 1];
            const numPlayed = cardsToPlay.length;

            // Check win condition first
            const hasWon = await checkWinCondition(humanPlayerIndex);
            if (hasWon) return;

            whotRequest = null;
            if (lastCard.number !== 1) holdOnActive = false;

            if (gameMode === 'multiplayer') {
                await updateServerGameState({});
            }

            switch (lastCard.number) {
                case 1: 
                    renderGame();
                    break;
                case 14:
                    // General Market - deal one card to each other player for each 14 played
                    const marketCardsCount = numPlayed;
                    showToast(`General Market! Everyone gets ${marketCardsCount} card${marketCardsCount > 1 ? 's' : ''}`, 'info');
                    
                    for (let i = 0; i < players.length; i++) {
                        if (i !== humanPlayerIndex && !eliminatedPlayers.includes(i)) {
                            for (let j = 0; j < marketCardsCount; j++) {
                                await dealCardToPlayer(i);
                                await new Promise(r => setTimeout(r, 50));
                            }
                        }
                    }
                    
                    renderGame();
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({});
                    }
                    break;
                case 8: 
                    turnsToSkip = numPlayed;
                    endTurn();
                    break;
                case 20: 
                    if (activeStack) { activeStack = null; }
                    requestShapeFromPlayer();
                    break;
                case 2: case 5: 
                    const penaltyCardNumber = lastCard.number;
                    if (activeStack && activeStack.card === penaltyCardNumber) {
                        activeStack.count += numPlayed;
                    } else {
                        activeStack = { card: penaltyCardNumber, count: numPlayed };
                    }
                    renderGame();
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({});
                    }
                    
                    endTurn();
                    break;
                default:
                    endTurn();
                    break;
            }
        }

        async function playCard(card, playerIdx) {
            discardPile.push(card);
            whotRequest = null;
            if (card.number !== 1) holdOnActive = false;

            // Check win condition first
            const hasWon = await checkWinCondition(playerIdx);
            if (hasWon) return;

            renderGame();
            
            if (gameMode === 'multiplayer') {
                await updateServerGameState({});
            }
            
            await applyCardEffect(card, playerIdx);
        }

        async function applyCardEffect(card, playerIdx) {
            let shouldEndTurn = true;

            switch (card.number) {
                case 1:
                    shouldEndTurn = false;
                    if (players[playerIdx].isHuman) {
                        renderGame();
                    } else {
                        setTimeout(() => botTurn(), 1000);
                    }
                    break;
                case 14:
                    // General Market - automatically deal one card to every other player
                    showToast('General Market! Everyone gets a card', 'info');
                    
                    for (let i = 0; i < players.length; i++) {
                        if (i !== playerIdx && !eliminatedPlayers.includes(i)) {
                            await dealCardToPlayer(i);
                            await new Promise(r => setTimeout(r, 100)); // Small delay for visual effect
                        }
                    }
                    
                    renderGame();
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({});
                    }
                    
                    // 14 is like Hold On - player continues their turn
                    shouldEndTurn = false;
                    if (players[playerIdx].isHuman) {
                        renderGame();
                    } else {
                        setTimeout(() => botTurn(), 1000);
                    }
                    break;
                case 8:
                    turnsToSkip = 1;
                    break;
                case 20:
                    if (activeStack) { activeStack = null; }
                    if (players[playerIdx].isHuman) {
                        requestShapeFromPlayer();
                        shouldEndTurn = false;
                    } else {
                        const chosenShape = chooseBestShapeForBot(players[playerIdx]);
                        whotRequest = { shape: chosenShape };
                        const topCard = discardPile[discardPile.length - 1];
                        if (topCard && topCard.number === 20) {
                            // Create a new card object to avoid modifying the original
                            discardPile[discardPile.length - 1] = {
                                ...topCard,
                                shape: chosenShape
                            };
                        }
                        renderGame();
                        
                        if (gameMode === 'multiplayer') {
                            await updateServerGameState({});
                        }
                    }
                    break;
                case 2: case 5:
                    if (activeStack && activeStack.card === card.number) {
                        activeStack.count++;
                    } else {
                        activeStack = { card: card.number, count: 1 };
                    }
                    renderGame();
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({});
                    }
                    break;
            }

            if (shouldEndTurn) {
                endTurn();
            }
        }

        async function endTurn() {
            let nextPlayerIndex = (currentPlayerIndex + 1 + turnsToSkip) % players.length;
            turnsToSkip = 0;
            
            // Skip eliminated players
            nextPlayerIndex = findNextActivePlayer(nextPlayerIndex);
            currentPlayerIndex = nextPlayerIndex;
            
            if (gameMode === 'multiplayer') {
                await updateServerGameState({});
            }
            
            setTimeout(() => {
                renderGame();
                if (!players[currentPlayerIndex].isHuman && !eliminatedPlayers.includes(currentPlayerIndex)) {
                    botTurn();
                }
            }, 800);
        }

        async function handlePlayerDraw() {
            const humanPlayerIndex = players.findIndex(p => p.isHuman);
            
            if (generalMarketState.active) {
                if (currentPlayerIndex === humanPlayerIndex && !generalMarketState.respondedMask[humanPlayerIndex]) {
                    generalMarketState.respondedMask[humanPlayerIndex] = true;
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({});
                    }
                    
                    checkIfMarketIsOver();
                }
                return;
            }
            
            if (currentPlayerIndex !== humanPlayerIndex) return;

            holdOnActive = false;

            if (activeStack) {
                const penalty = activeStack.card === 2 ? 2 : 3;
                const totalCards = activeStack.count * penalty;
                for(let i = 0; i < totalCards; i++) await dealCardToPlayer(currentPlayerIndex);
                activeStack = null;
            } else {
                await dealCardToPlayer(currentPlayerIndex);
            }
            renderGame();
            
            if (gameMode === 'multiplayer') {
                await updateServerGameState({});
            }
            
            endTurn();
        }

        // Bot AI functions with universal card ordering
        async function botTurn() {
            updateStatusMessage();
            await new Promise(r => setTimeout(r, 1200));
            
            const bot = players[currentPlayerIndex];

            if (activeStack) {
                const whotCard = bot.hand.find(c => c.number === 20);
                if (whotCard) {
                    bot.hand = bot.hand.filter(c => c !== whotCard);
                    await animateCardPlayFromComputer(whotCard);
                    await playCard(whotCard, currentPlayerIndex);
                    return;
                }
                const counterCard = bot.hand.find(c => c.number === activeStack.card);
                if (counterCard) {
                    bot.hand = bot.hand.filter(c => c !== counterCard);
                    await animateCardPlayFromComputer(counterCard);
                    await playCard(counterCard, currentPlayerIndex);
                    return;
                } else {
                    const penalty = activeStack.card === 2 ? 2 : 3;
                    const totalCards = activeStack.count * penalty;
                    for(let i = 0; i < totalCards; i++) await dealCardToPlayer(currentPlayerIndex);
                    activeStack = null;
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({});
                    }
                    
                    endTurn();
                    return;
                }
            }

            const playableCards = bot.hand.filter(c => isCardPlayable(c));
            if (playableCards.length > 0) {
                // Check for push opportunities (multiple cards of same number)
                const numberCounts = {};
                playableCards.forEach(card => {
                    numberCounts[card.number] = (numberCounts[card.number] || 0) + 1;
                });
                
                const pushableNumber = Object.keys(numberCounts).find(num => numberCounts[num] > 1);
                
                if (pushableNumber) {
                    // Bot will push multiple cards - use universal ordering
                    let cardsToPlay = bot.hand.filter(c => c.number === parseInt(pushableNumber));
                    cardsToPlay = sortCardsForValidPlay(cardsToPlay);
                    
                    // Remove all cards of this number from bot's hand
                    bot.hand = bot.hand.filter(c => c.number !== parseInt(pushableNumber));
                    
                    // Play cards in correct order
                    for (const card of cardsToPlay) {
                        await animateCardPlayFromComputer(card);
                        discardPile.push(card);
                        renderGame();
                        await new Promise(r => setTimeout(r, 100));
                    }
                    
                    const lastCard = cardsToPlay[cardsToPlay.length - 1];
                    
                    // Handle the last card's effect
                    const hasWon = await checkWinCondition(currentPlayerIndex);
                    if (hasWon) return;

                    whotRequest = null;
                    if (lastCard.number !== 1) holdOnActive = false;

                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({});
                    }

                    await applyCardEffect(lastCard, currentPlayerIndex);
                    return;
                } else {
                    // Single card play - prioritize special cards
                    const specialCard = playableCards.find(c => [1, 2, 5, 8, 14, 20].includes(c.number));
                    let cardToPlay = specialCard || playableCards[0];
                    
                    bot.hand = bot.hand.filter(c => c !== cardToPlay);
                    await animateCardPlayFromComputer(cardToPlay);
                    await playCard(cardToPlay, currentPlayerIndex);
                }
            } else {
                holdOnActive = false;
                await dealCardToPlayer(currentPlayerIndex);
                
                if (gameMode === 'multiplayer') {
                    await updateServerGameState({});
                }
                
                endTurn();
            }
        }

        function chooseBestShapeForBot(bot) {
            const shapeCounts = {};
            bot.hand.forEach(card => {
                if (card.shape !== 'whot') shapeCounts[card.shape] = (shapeCounts[card.shape] || 0) + 1;
            });
            let bestShape = 'circle', maxCount = 0;
            for (const shape in shapeCounts) {
                if (shapeCounts[shape] > maxCount) { maxCount = shapeCounts[shape]; bestShape = shape; }
            }
            return bestShape;
        }

        // General Market functions
        function respondToMarketAsBot(botIndex) {
            if (eliminatedPlayers.includes(botIndex)) return;
            
            setTimeout(async () => {
                const bot = players[botIndex];
                const marketCard = bot.hand.find(c => c.number === 14);

                if (marketCard) {
                    bot.hand = bot.hand.filter(c => c !== marketCard);
                    generalMarketState.playersWhoPlayed.push(botIndex);
                    await animateCardPlayFromComputer(marketCard, botIndex);
                    discardPile.push(marketCard);
                    renderGame();
                }

                generalMarketState.respondedMask[botIndex] = true;
                
                if (gameMode === 'multiplayer') {
                    await updateServerGameState({});
                }
                
                checkIfMarketIsOver();
            }, 1000 + Math.random() * 500);
        }

        function checkIfMarketIsOver() {
            if (!generalMarketState.active) return;
            
            console.log('Checking if market is over:', generalMarketState);
            
            // Check only non-eliminated players
            const activePlayers = players.filter((_, i) => !eliminatedPlayers.includes(i));
            const allActiveResponded = activePlayers.every((player) => {
                const realIndex = players.findIndex(p => p.id === player.id);
                const hasResponded = generalMarketState.respondedMask[realIndex] === true;
                console.log(`Player ${player.name} (index ${realIndex}) responded: ${hasResponded}`);
                return hasResponded;
            });
            
            console.log('All players responded:', allActiveResponded);
            
            if (allActiveResponded) {
                resolveGeneralMarket();
            }
        }

        async function resolveGeneralMarket() {
            const penaltyCount = generalMarketState.playersWhoPlayed.length;
            for (let i = 0; i < players.length; i++) {
                if (!generalMarketState.playersWhoPlayed.includes(i) && !eliminatedPlayers.includes(i)) {
                    for (let j = 0; j < penaltyCount; j++) {
                        await dealCardToPlayer(i);
                    }
                }
            }
            
            currentPlayerIndex = generalMarketState.initiator;
            generalMarketState = { active: false, initiator: null, respondedMask: [], playersWhoPlayed: [] };
            
            renderGame();
            
            if (gameMode === 'multiplayer') {
                await updateServerGameState({});
            }
            
            if (!players[currentPlayerIndex].isHuman && !eliminatedPlayers.includes(currentPlayerIndex)) {
                setTimeout(() => botTurn(), 1000);
            }
        }

        // Shape selection functions
        function requestShapeFromPlayer() {
            shapeOptionsDiv.innerHTML = '';
            Object.keys(SHAPES_SVG).forEach(shape => {
                const optionDiv = document.createElement('div');
                optionDiv.className = `shape-option w-20 h-20 flex items-center justify-center rounded-full bg-gray-700 cursor-pointer text-white`;
                optionDiv.innerHTML = `<div class="w-12 h-12">${SHAPES_SVG[shape]}</div>`;
                optionDiv.addEventListener('click', () => selectShape(shape));
                shapeOptionsDiv.appendChild(optionDiv);
            });
            shapeModal.classList.remove('hidden');
            setTimeout(() => shapeModal.classList.remove('opacity-0'), 10);
        }

        async function selectShape(shape) {
            whotRequest = { shape };
            const topCard = discardPile[discardPile.length - 1];
            if (topCard && topCard.number === 20) {
                // Create a new card object to avoid modifying the original
                discardPile[discardPile.length - 1] = {
                    ...topCard,
                    shape: shape
                };
            }
            shapeModal.classList.add('opacity-0');
            setTimeout(() => shapeModal.classList.add('hidden'), 300);
            renderGame();
            
            if (gameMode === 'multiplayer') {
                await updateServerGameState({});
            }
            
            endTurn();
        }

        // Win condition
        function endGame(winner, isTournamentWin = false) {
            const winnerMessage = document.createElement('div');
            winnerMessage.className = "winner-message absolute inset-0 bg-black/70 flex items-center justify-center text-4xl font-bold z-50";
            
            if (isTournamentWin) {
                // In elimination mode, show tournament results
                const remainingPlayers = players.filter((_, i) => !eliminatedPlayers.includes(i));
                const tournamentWinner = remainingPlayers.length > 0 ? remainingPlayers[0] : null;
                winnerMessage.innerHTML = `
                    <div class="text-center">
                        <div class="text-6xl mb-4">🏆</div>
                        <div>TOURNAMENT COMPLETE!</div>
                        ${tournamentWinner ? `<div class="text-2xl mt-4">${tournamentWinner.name.toUpperCase()} WINS THE TOURNAMENT!</div>` : ''}
                    </div>
                `;
            } else if (winner) {
                winnerMessage.textContent = `${winner.name.toUpperCase()} WINS!`;
            } else {
                winnerMessage.textContent = "GAME COMPLETE!";
            }
            
            document.getElementById('game-container').appendChild(winnerMessage);

            setTimeout(() => {
                gameContainer.classList.add('hidden');
                gameContainer.classList.remove('flex');
                
                // Reset to main menu
                eliminatedPlayers = [];
                if (gameMode === 'multiplayer' && currentGameId) {
                    // Clean up multiplayer game
                    if (isHost) {
                        window.firebase.remove(window.firebase.ref(window.firebase.database, `games/${currentGameId}`));
                    }
                    if (playersRef) window.firebase.off(playersRef);
                    if (gameStateRef) window.firebase.off(gameStateRef);
                    currentGameId = null;
                    playerId = null;
                    isHost = false;
                }
                mainMenu.classList.remove('hidden');
            }, 4000);
        }

        // Animation functions
        function animateCardDraw(targetElement) {
            return new Promise(resolve => {
                const startRect = drawPileDiv.getBoundingClientRect();
                const targetRect = targetElement.getBoundingClientRect();
                const animCard = document.createElement('div');
                animCard.className = 'card card-back drawing-card';
                animCard.innerHTML = createCardElement(null, false).innerHTML;
                document.body.appendChild(animCard);
                animCard.style.left = `${startRect.left}px`;
                animCard.style.top = `${startRect.top}px`;
                requestAnimationFrame(() => {
                    const endX = targetRect.left + (targetRect.width / 2) - (startRect.width / 2);
                    const endY = targetRect.top;
                    animCard.style.transform = `translate(${endX - startRect.left}px, ${endY - startRect.top}px)`;
                });
                setTimeout(() => {
                    animCard.remove();
                    resolve();
                }, 400);
            });
        }

        function animateCardPlayFromPosition(card, startRect, handName) {
             return new Promise(resolve => {
                if (!startRect) { 
                    const handDiv = handName === 'action' ? rightHandDiv : leftHandDiv;
                    const handRect = handDiv.getBoundingClientRect();
                    startRect = { left: handRect.left + handRect.width / 2 - 60, top: handRect.top };
                }
                
                const lastCardInPile = discardPileDiv.querySelector('.card:last-child');
                const targetRect = lastCardInPile ? lastCardInPile.getBoundingClientRect() : discardPileDiv.getBoundingClientRect();

                const animCard = document.createElement('div');
                animCard.className = 'card drawing-card';
                animCard.innerHTML = createCardElement(card, true).innerHTML;
                document.body.appendChild(animCard);
                animCard.style.left = `${startRect.left}px`;
                animCard.style.top = `${startRect.top}px`;
                animCard.style.width = '120px';
                animCard.style.height = '180px';
                
                requestAnimationFrame(() => {
                    const endX = targetRect.left;
                    const endY = targetRect.top;
                    animCard.style.transform = `translate(${endX - startRect.left}px, ${endY - startRect.top}px)`;
                });
                
                setTimeout(() => {
                    animCard.remove();
                    resolve();
                }, 400);
            });
        }

        function animateCardPlayFromComputer(card, playerIndex = currentPlayerIndex) {
            return new Promise(resolve => {
                const botProfiles = document.querySelectorAll('.computer-player-profile');
                const botProfile = Array.from(botProfiles).find(p => {
                    const nameDiv = p.querySelector('.font-semibold');
                    return nameDiv && nameDiv.textContent === players[playerIndex].name;
                });

                const startRect = botProfile ? botProfile.getBoundingClientRect() : { left: 0, top: 0, width: 120, height: 180 };
                
                const lastCardInPile = discardPileDiv.querySelector('.card:last-child');
                const targetRect = lastCardInPile ? lastCardInPile.getBoundingClientRect() : discardPileDiv.getBoundingClientRect();

                const animCard = document.createElement('div');
                animCard.className = 'card drawing-card';
                animCard.innerHTML = createCardElement(card, true).innerHTML;
                document.body.appendChild(animCard);
                animCard.style.left = `${startRect.left + startRect.width / 2 - 60}px`;
                animCard.style.top = `${startRect.top}px`;
                animCard.style.width = '120px';
                animCard.style.height = '180px';

                animCard.addEventListener('transitionend', () => {
                    animCard.remove();
                    resolve();
                }, { once: true });

                requestAnimationFrame(() => {
                    const endX = targetRect.left;
                    const endY = targetRect.top;
                    animCard.style.transform = `translate(${endX - (startRect.left + startRect.width / 2 - 60)}px, ${endY - startRect.top}px)`;
                });

                // Fallback in case transitionend doesn't fire
                setTimeout(() => {
                    if (animCard.parentNode) {
                        animCard.remove();
                        resolve();
                    }
                }, 500);
            });
        }

        // Event listeners and initialization
        drawPileDiv.addEventListener('click', handlePlayerDraw);
        
        // Game code input formatting
        document.getElementById('game-code-input').addEventListener('input', (e) => {
            let value = e.target.value.replace(/\D/g, '').slice(0, 6);
            e.target.value = value;
        });

        // Player name input validation
        document.getElementById('player-name-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('create-game-btn').click();
            }
        });

        document.getElementById('game-code-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('join-game-btn').click();
            }
        });
        
        // Initialize drag and drop when page loads
        window.onload = () => {
            setupDragAndDrop();
        };

        window.addEventListener('resize', renderGame);

        // Handle window close/refresh for multiplayer cleanup
        window.addEventListener('beforeunload', () => {
            if (gameMode === 'multiplayer' && currentGameId && playerId) {
                if (isHost) {
                    // Host leaving - delete game
                    navigator.sendBeacon(`https://whotwhotnigeria-default-rtdb.firebaseio.com/games/${currentGameId}.json`, JSON.stringify(null));
                } else {
                    // Player leaving - remove from players
                    navigator.sendBeacon(`https://whotwhotnigeria-default-rtdb.firebaseio.com/games/${currentGameId}/players/${playerId}.json`, JSON.stringify(null));
                }
            }
        });

        // Multiplayer game state sync handler
        function handleGameEnd(serverState) {
            if (serverState.winner) {
                const winner = players.find(p => p.id === serverState.winner.id);
                endGame(winner, serverState.isTournamentWin);
            }
        }

        // Error handling for Firebase operations
        window.addEventListener('online', () => {
            if (gameMode === 'multiplayer' && currentGameId) {
                showToast('Connection restored', 'success');
            }
        });

        window.addEventListener('offline', () => {
            if (gameMode === 'multiplayer') {
                showToast('Connection lost - game may not sync properly', 'error');
            }
        });

        // Initialize the game - ensure all screens are hidden except main menu
        function initializeApp() {
            // Hide all screens except main menu (remove flex from all)
            setupScreen.classList.add('hidden');
            setupScreen.classList.remove('flex');
            multiplayerSetup.classList.add('hidden');
            multiplayerSetup.classList.remove('flex');
            gameModeScreen.classList.add('hidden');
            gameModeScreen.classList.remove('flex');
            lobbyScreen.classList.add('hidden');
            lobbyScreen.classList.remove('flex');
            readyCheckScreen.classList.add('hidden');
            readyCheckScreen.classList.remove('flex');
            gameContainer.classList.add('hidden');
            gameContainer.classList.remove('flex');
            
            // Show main menu only
            mainMenu.classList.remove('hidden');
        }

        // Initialize the game
        console.log('Nigerian Whot Game - Multiplayer Edition Loaded');
        
        // Initialize app state on load
        window.addEventListener('DOMContentLoaded', initializeApp);
        
        // Initialize drag and drop when page loads
        window.onload = () => {
            setupDragAndDrop();
            initializeApp(); // Ensure proper initialization
        };
        
        // Debug helper (remove in production)
        window.debugGame = {
            players: () => players,
            gameState: () => ({
                discardPile,
                drawPile: drawPile.length,
                currentPlayerIndex,
                activeStack,
                whotRequest,
                eliminatedPlayers
            }),
            firebase: () => window.firebase
        };
    </script>
</body>
</html>