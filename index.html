<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nigerian Whot Game - Multiplayer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Tinos:wght@700&family=Dancing+Script:wght@700&display=swap" rel="stylesheet">
    <style>
        * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        body {
            font-family: 'Poppins', sans-serif;
            touch-action: manipulation;
        }
        .card {
            width: 120px;
            height: 180px;
            border: 1px solid #888;
            border-radius: 10px;
            background-color: #f8f8f8;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            color: #8C1C13;
            font-family: 'Tinos', serif;
            font-weight: 700;
        }
        .card.dragging {
            opacity: 0.3;
            transform: rotate(5deg) scale(0.9) !important;
            z-index: 1000 !important;
            pointer-events: none;
        }
        .drop-zone {
            border: 2px dashed #4ade80 !important;
            background-color: rgba(74, 222, 128, 0.1) !important;
            border-radius: 8px !important;
        }
        .card-back {
            background-color: #8C1C13;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 1rem;
        }
        .whot-text-back {
            font-family: 'Dancing Script', cursive;
            font-size: 34px;
            color: white;
            line-height: 1;
        }
        .card-symbol {
            width: 70px;
            height: 70px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .corner {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 24px;
            line-height: 1;
        }
        .corner-shape {
            width: 14px;
            height: 14px;
        }
        .top-left { top: 10px; left: 10px; }
        .bottom-right { bottom: 10px; right: 10px; transform: rotate(180deg); }
        .whot-card-center {
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .whot-text {
            font-family: 'Dancing Script', cursive;
            font-size: 38px;
            line-height: 1;
        }
        .player-hand-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 220px;
            position: relative;
        }
        .player-hand-container .card, #right-hand .card {
            position: absolute;
            transition: transform 0.3s ease;
        }
        .computer-player-profile {
            position: relative;
            width: 140px;
            height: 220px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 8px;
            border-radius: 8px;
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        .computer-player-profile.active-turn {
            background-color: #ca8a04;
            box-shadow: 0 0 15px #ca8a04;
        }
        .bot-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid white;
            object-fit: cover;
            background-color: #4a5568;
        }
        .card-stack-container {
            position: relative;
            width: 120px;
            height: 180px;
        }
        .card-stack-container .card {
            position: absolute;
            top: 0;
            left: 0;
            cursor: default;
        }
        .card-stack-container .card:hover {
            transform: none;
        }
        #game-board {
            perspective: 1000px;
        }
        #shape-modal {
            transition: opacity 0.3s ease-in-out;
        }
        .shape-option {
            transition: transform 0.2s;
        }
        .shape-option:hover {
            transform: scale(1.1);
        }
        .toast {
            animation: fade-in-out 3s forwards;
        }
        @keyframes fade-in-out {
            0% { opacity: 0; transform: translateY(20px); }
            15% { opacity: 1; transform: translateY(0); }
            85% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        .drawing-card {
            position: fixed;
            z-index: 100;
            transition: transform 0.4s ease-in-out, opacity 0.4s;
        }
        .push-button {
            background-color: #ca8a04;
            color: white;
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .push-button:hover {
            background-color: #a16207;
        }
        .eliminated {
            opacity: 0.5;
            filter: grayscale(1);
        }
        #rotate-device-overlay {
            display: none;
        }
        @media (max-width: 768px) and (orientation: portrait) {
            #game-container, #setup-screen, #multiplayer-setup, #lobby-screen {
                display: none !important;
            }
            #rotate-device-overlay {
                display: flex;
            }
        }
        @media (max-width: 1024px) {
            .card {
                width: 90px;
                height: 135px;
            }
            .corner {
                font-size: 18px;
            }
            .whot-text {
                font-size: 28px;
            }
            .card-symbol {
                width: 50px;
                height: 50px;
            }
            .player-hand-container {
                min-height: 160px;
            }
            .computer-player-profile {
                width: 110px;
                height: 180px;
            }
            .bot-avatar {
                width: 40px;
                height: 40px;
            }
            .card-stack-container {
                width: 90px;
                height: 135px;
            }
            #game-board {
                gap: 1rem;
            }
            #discard-pile {
                width: 220px !important;
                height: 135px !important;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center min-h-screen p-4 overflow-hidden">

    <!-- Main Menu -->
    <div id="main-menu" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl text-center w-full max-w-md">
            <h1 class="text-4xl font-bold mb-8" style="font-family: 'Dancing Script', cursive;">Nigerian Whot</h1>
            <div class="flex flex-col gap-4">
                <button id="single-player-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg text-xl transition-colors">
                    Single Player
                </button>
                <button id="multiplayer-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg text-xl transition-colors">
                    Multiplayer
                </button>
            </div>
        </div>
    </div>

    <!-- Single Player Setup -->
    <div id="setup-screen" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl text-center w-full max-w-md">
            <h2 class="text-3xl font-bold mb-2">Single Player</h2>
            <p class="mb-6 text-gray-400">Game Setup</p>
            <div class="mb-6">
                <label class="block mb-2 text-lg font-medium">Select Number of Opponents</label>
                <div class="flex items-center justify-center gap-4">
                    <button id="decrement-players" class="px-4 py-2 bg-amber-600 rounded-md text-xl font-bold">-</button>
                    <span id="player-count-display" class="text-3xl font-bold w-16 text-center">1</span>
                    <button id="increment-players" class="px-4 py-2 bg-amber-600 rounded-md text-xl font-bold">+</button>
                </div>
            </div>
            <div class="flex gap-4">
                <button id="back-to-menu-single" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Back
                </button>
                <button id="start-single-game-btn" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Start Game
                </button>
            </div>
        </div>
    </div>

    <!-- Multiplayer Setup -->
    <div id="multiplayer-setup" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl text-center w-full max-w-md">
            <h2 class="text-3xl font-bold mb-6">Multiplayer</h2>
            <div class="flex flex-col gap-4">
                <input type="text" id="player-name-input" placeholder="Enter your name" class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" maxlength="20">
                <button id="create-game-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Create New Game
                </button>
                <div class="relative">
                    <div class="absolute inset-0 flex items-center">
                        <div class="w-full border-t border-gray-600"></div>
                    </div>
                    <div class="relative flex justify-center text-sm">
                        <span class="px-2 bg-gray-800 text-gray-400">OR</span>
                    </div>
                </div>
                <input type="text" id="game-code-input" placeholder="Enter 6-digit game code" class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 text-center text-xl tracking-wider" maxlength="6">
                <button id="join-game-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Join Game
                </button>
                <button id="back-to-menu-multi" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Back
                </button>
            </div>
        </div>
    </div>

    <!-- Game Mode Selection -->
    <div id="game-mode-screen" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl text-center w-full max-w-md">
            <h2 class="text-3xl font-bold mb-6">Select Game Mode</h2>
            <div class="flex flex-col gap-4">
                <div class="bg-gray-700 p-4 rounded-lg cursor-pointer hover:bg-gray-600 transition-colors" id="counting-mode">
                    <h3 class="text-xl font-bold mb-2">Counting Cards Mode</h3>
                    <p class="text-sm text-gray-300">When someone finishes, count remaining cards. Highest total gets eliminated.</p>
                </div>
                <div class="bg-gray-700 p-4 rounded-lg cursor-pointer hover:bg-gray-600 transition-colors" id="elimination-mode">
                    <h3 class="text-xl font-bold mb-2">Last Standing Mode</h3>
                    <p class="text-sm text-gray-300">Keep playing until last person standing, then they get eliminated. Tournament style!</p>
                </div>
            </div>
            <button id="back-to-setup" class="w-full mt-6 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                Back
            </button>
        </div>
    </div>

    <!-- Multiplayer Lobby -->
    <div id="lobby-screen" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl text-center w-full max-w-md">
            <h2 class="text-3xl font-bold mb-2">Game Lobby</h2>
            <div class="mb-4">
                <p class="text-gray-400 mb-2">Game Code:</p>
                <p id="lobby-game-code" class="text-4xl font-bold tracking-wider text-green-400"></p>
            </div>
            <div class="mb-4">
                <p class="text-gray-400 mb-2">Game Mode:</p>
                <p id="lobby-game-mode" class="text-lg font-semibold text-blue-400"></p>
            </div>
            <div class="mb-6">
                <p class="text-gray-400 mb-2">Players:</p>
                <div id="lobby-players" class="space-y-2"></div>
            </div>
            <div class="flex gap-4">
                <button id="leave-lobby-btn" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    Leave
                </button>
                <button id="start-multiplayer-game-btn" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors hidden">
                    Start Game
                </button>
            </div>
            <div id="waiting-message" class="mt-4 text-gray-400">Waiting for host to start game...</div>
        </div>
    </div>

    <div id="game-container" class="w-full max-w-screen-2xl mx-auto flex flex-col items-center justify-between flex-grow hidden">
        <!-- Eliminated Players Bar -->
        <div id="eliminated-bar" class="w-full bg-red-900/50 p-2 text-center text-red-200 hidden">
            <span id="eliminated-text">Eliminated: </span>
        </div>

        <!-- Computer's Area -->
        <div class="w-full">
            <div id="computer-players-area" class="flex flex-wrap justify-center items-start gap-4 md:gap-12"></div>
        </div>

        <!-- Game Board -->
        <div id="game-board" class="flex items-center justify-center gap-4 md:gap-16 my-2 w-full">
            <div id="draw-pile" class="card-stack-container"></div>
            <div id="game-status" class="text-center text-2xl md:text-3xl font-bold leading-tight w-28 md:w-40"></div>
            <div id="discard-pile" class="relative w-[300px] h-[180px]"></div>
        </div>
        
        <!-- Player's Area -->
        <div class="w-full p-2 md:p-4 bg-gray-800/50 rounded-xl">
            <div class="grid grid-cols-2 gap-2 md:gap-4">
                <div class="flex flex-col items-center">
                    <div id="left-hand" class="player-hand-container w-full"></div>
                    <div id="left-push-buttons" class="flex gap-2 mt-2"></div>
                </div>
                <div class="flex flex-col items-center">
                    <div id="right-hand" class="player-hand-container w-full"></div>
                     <div id="right-push-buttons" class="flex gap-2 mt-2"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Rotate Device Overlay -->
    <div id="rotate-device-overlay" class="fixed inset-0 bg-gray-900 z-50 items-center justify-center text-center">
        <div>
            <svg class="w-24 h-24 mx-auto text-white mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 18h.01M8 21h8a2 2 0 002-2V5a2 2 0 00-2-2H8a2 2 0 00-2 2v14a2 2 0 002 2zM5 12h.01M19 12h.01M21 8v.01M21 16v.01M3 8v.01M3 16v.01"></path></svg>
            <h2 class="text-2xl font-bold">Please Rotate Your Device</h2>
            <p class="text-gray-400 mt-2">This game is best played in landscape mode.</p>
        </div>
    </div>

    <!-- Shape Selection Modal -->
    <div id="shape-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50 opacity-0">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl text-center">
            <h2 class="text-2xl font-bold mb-6">Choose a Shape</h2>
            <div id="shape-options" class="flex gap-4"></div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast-container" class="fixed bottom-5 right-5 z-50"></div>

    <!-- Firebase Scripts -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
        import { getDatabase, ref, set, get, onValue, off, push, remove, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAfxzfnXrLtgqBzDZxgI1EMxso8E6iEYf0",
            authDomain: "whotwhotnigeria.firebaseapp.com",
            databaseURL: "https://whotwhotnigeria-default-rtdb.firebaseio.com",
            projectId: "whotwhotnigeria",
            storageBucket: "whotwhotnigeria.firebasestorage.app",
            messagingSenderId: "686057562811",
            appId: "1:686057562811:web:ae26e37cfa2fc2fadd7f9e",
            measurementId: "G-C2SGLN7788"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        
        window.firebase = { database, ref, set, get, onValue, off, push, remove, serverTimestamp };
    </script>

    <script>
        // DOM Elements
        const mainMenu = document.getElementById('main-menu');
        const setupScreen = document.getElementById('setup-screen');
        const multiplayerSetup = document.getElementById('multiplayer-setup');
        const gameModeScreen = document.getElementById('game-mode-screen');
        const lobbyScreen = document.getElementById('lobby-screen');
        const gameContainer = document.getElementById('game-container');

        // Game State
        let gameMode = 'single'; // 'single' or 'multiplayer'
        let gameType = 'counting'; // 'counting' or 'elimination'
        let isHost = false;
        let currentGameId = null;
        let playerId = null;
        let playerName = 'Player';
        let gameStateRef = null;
        let playersRef = null;
        let eliminatedPlayers = [];
        
        // Existing game state variables
        let deck = [];
        let players = [];
        let discardPile = [];
        let drawPile = [];
        let currentPlayerIndex = 0;
        let activeStack = null; 
        let whotRequest = null; 
        let holdOnActive = false;
        let turnsToSkip = 0;
        let draggedCardData = null;
        let isDragging = false;
        let generalMarketState = { active: false, initiator: null, respondedMask: [], playersWhoPlayed: [] };

        const ACTION_CARDS = [1, 2, 5, 8, 14, 20];
        
        const SHAPES_SVG = {
            circle: `<svg viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="11"/></svg>`,
            triangle: `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L1 21h22L12 2z"/></svg>`,
            square: `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M3 3h18v18H3V3z"/></svg>`,
            cross: `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M10 3 H14 V10 H21 V14 H14 V21 H10 V14 H3 V10 H10z"/></svg>`,
            star: `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>`
        };

        const BOT_NAMES = ["Apex", "Bolt", "Cipher", "Dynamo", "Echo", "Fusion", "Glitch", "Helix", "Ion", "Jolt", "Kortex", "Logic"];

        // Firebase helper functions
        function generateGameId() {
            return Math.floor(100000 + Math.random() * 900000).toString();
        }

        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substr(2, 9);
        }

        // Menu Navigation
        document.getElementById('single-player-btn').addEventListener('click', () => {
            gameMode = 'single';
            mainMenu.classList.add('hidden');
            gameModeScreen.classList.remove('hidden');
        });

        document.getElementById('multiplayer-btn').addEventListener('click', () => {
            gameMode = 'multiplayer';
            mainMenu.classList.add('hidden');
            multiplayerSetup.classList.remove('hidden');
        });

        document.getElementById('back-to-menu-single').addEventListener('click', () => {
            setupScreen.classList.add('hidden');
            mainMenu.classList.remove('hidden');
        });

        document.getElementById('back-to-menu-multi').addEventListener('click', () => {
            multiplayerSetup.classList.add('hidden');
            mainMenu.classList.remove('hidden');
        });

        document.getElementById('back-to-setup').addEventListener('click', () => {
            gameModeScreen.classList.add('hidden');
            if (gameMode === 'single') {
                mainMenu.classList.remove('hidden');
            } else {
                multiplayerSetup.classList.remove('hidden');
            }
        });

        // Game Mode Selection
        document.getElementById('counting-mode').addEventListener('click', () => {
            gameType = 'counting';
            gameModeScreen.classList.add('hidden');
            if (gameMode === 'single') {
                setupScreen.classList.remove('hidden');
            } else {
                multiplayerSetup.classList.remove('hidden');
            }
        });

        document.getElementById('elimination-mode').addEventListener('click', () => {
            gameType = 'elimination';
            gameModeScreen.classList.add('hidden');
            if (gameMode === 'single') {
                setupScreen.classList.remove('hidden');
            } else {
                multiplayerSetup.classList.remove('hidden');
            }
        });

        // Multiplayer Functions
        document.getElementById('create-game-btn').addEventListener('click', async () => {
            const nameInput = document.getElementById('player-name-input');
            if (!nameInput.value.trim()) {
                showToast('Please enter your name', 'error');
                return;
            }
            
            playerName = nameInput.value.trim();
            playerId = generatePlayerId();
            currentGameId = generateGameId();
            isHost = true;

            try {
                // Create game in Firebase
                const gameData = {
                    id: currentGameId,
                    host: playerId,
                    gameType: gameType,
                    status: 'waiting',
                    createdAt: window.firebase.serverTimestamp(),
                    players: {
                        [playerId]: {
                            id: playerId,
                            name: playerName,
                            isHost: true,
                            joinedAt: window.firebase.serverTimestamp()
                        }
                    }
                };

                await window.firebase.set(window.firebase.ref(window.firebase.database, `games/${currentGameId}`), gameData);
                
                multiplayerSetup.classList.add('hidden');
                showLobby();
            } catch (error) {
                console.error('Error creating game:', error);
                showToast('Error creating game', 'error');
            }
        });

        document.getElementById('join-game-btn').addEventListener('click', async () => {
            const nameInput = document.getElementById('player-name-input');
            const codeInput = document.getElementById('game-code-input');
            
            if (!nameInput.value.trim()) {
                showToast('Please enter your name', 'error');
                return;
            }
            
            if (!codeInput.value.trim() || codeInput.value.length !== 6) {
                showToast('Please enter a valid 6-digit game code', 'error');
                return;
            }

            playerName = nameInput.value.trim();
            playerId = generatePlayerId();
            currentGameId = codeInput.value.trim();

            try {
                // Check if game exists
                const gameSnapshot = await window.firebase.get(window.firebase.ref(window.firebase.database, `games/${currentGameId}`));
                
                if (!gameSnapshot.exists()) {
                    showToast('Game not found', 'error');
                    return;
                }

                const gameData = gameSnapshot.val();
                
                if (gameData.status !== 'waiting') {
                    showToast('Game already in progress', 'error');
                    return;
                }

                // Join the game
                await window.firebase.set(window.firebase.ref(window.firebase.database, `games/${currentGameId}/players/${playerId}`), {
                    id: playerId,
                    name: playerName,
                    isHost: false,
                    joinedAt: window.firebase.serverTimestamp()
                });

                multiplayerSetup.classList.add('hidden');
                showLobby();
            } catch (error) {
                console.error('Error joining game:', error);
                showToast('Error joining game', 'error');
            }
        });

        function showLobby() {
            lobbyScreen.classList.remove('hidden');
            document.getElementById('lobby-game-code').textContent = currentGameId;
            document.getElementById('lobby-game-mode').textContent = gameType === 'counting' ? 'Counting Cards Mode' : 'Last Standing Mode';
            
            if (isHost) {
                document.getElementById('start-multiplayer-game-btn').classList.remove('hidden');
                document.getElementById('waiting-message').classList.add('hidden');
            }

            // Listen for players updates
            playersRef = window.firebase.ref(window.firebase.database, `games/${currentGameId}/players`);
            window.firebase.onValue(playersRef, (snapshot) => {
                const playersData = snapshot.val() || {};
                updateLobbyPlayers(playersData);
            });

            // Listen for game state updates
            gameStateRef = window.firebase.ref(window.firebase.database, `games/${currentGameId}`);
            window.firebase.onValue(gameStateRef, (snapshot) => {
                const gameData = snapshot.val();
                if (gameData && gameData.status === 'playing') {
                    startMultiplayerGame(gameData);
                }
            });
        }

        function updateLobbyPlayers(playersData) {
            const lobbyPlayersDiv = document.getElementById('lobby-players');
            lobbyPlayersDiv.innerHTML = '';
            
            Object.values(playersData).forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'bg-gray-700 p-2 rounded flex justify-between items-center';
                playerDiv.innerHTML = `
                    <span>${player.name}</span>
                    <span class="text-sm ${player.isHost ? 'text-yellow-400' : 'text-gray-400'}">${player.isHost ? 'Host' : 'Player'}</span>
                `;
                lobbyPlayersDiv.appendChild(playerDiv);
            });
        }

        document.getElementById('leave-lobby-btn').addEventListener('click', async () => {
            try {
                if (isHost) {
                    // Delete the entire game if host leaves
                    await window.firebase.remove(window.firebase.ref(window.firebase.database, `games/${currentGameId}`));
                } else {
                    // Remove player from game
                    await window.firebase.remove(window.firebase.ref(window.firebase.database, `games/${currentGameId}/players/${playerId}`));
                }
                
                // Clean up listeners
                if (playersRef) window.firebase.off(playersRef);
                if (gameStateRef) window.firebase.off(gameStateRef);
                
                lobbyScreen.classList.add('hidden');
                multiplayerSetup.classList.remove('hidden');
                currentGameId = null;
                playerId = null;
                isHost = false;
            } catch (error) {
                console.error('Error leaving lobby:', error);
            }
        });

        document.getElementById('start-multiplayer-game-btn').addEventListener('click', async () => {
            if (!isHost) return;

            try {
                // Get current players
                const playersSnapshot = await window.firebase.get(window.firebase.ref(window.firebase.database, `games/${currentGameId}/players`));
                const playersData = playersSnapshot.val() || {};
                
                if (Object.keys(playersData).length < 2) {
                    showToast('Need at least 2 players to start', 'error');
                    return;
                }

                // Update game status and initialize game state
                const gameUpdate = {
                    status: 'playing',
                    startedAt: window.firebase.serverTimestamp(),
                    gameState: {
                        currentPlayerIndex: 0,
                        deck: createDeck(),
                        discardPile: [],
                        activeStack: null,
                        whotRequest: null,
                        holdOnActive: false,
                        turnsToSkip: 0,
                        generalMarketState: { active: false, initiator: null, respondedMask: [], playersWhoPlayed: [] },
                        eliminatedPlayers: []
                    }
                };

                // Shuffle deck
                shuffleDeck(gameUpdate.gameState.deck);
                
                await window.firebase.set(window.firebase.ref(window.firebase.database, `games/${currentGameId}`), {
                    ...gameUpdate,
                    players: playersData
                });

            } catch (error) {
                console.error('Error starting game:', error);
                showToast('Error starting game', 'error');
            }
        });

        function startMultiplayerGame(gameData) {
            lobbyScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            gameContainer.classList.add('flex');
            
            // Convert Firebase players to game format
            const firebasePlayers = Object.values(gameData.players);
            players = firebasePlayers.map(p => ({
                id: p.id,
                name: p.name,
                isHuman: p.id === playerId,
                regularHand: [],
                actionHand: p.id === playerId ? [] : undefined,
                hand: p.id === playerId ? undefined : [],
                avatar: `https://placehold.co/50x50/4a5568/ffffff?text=${p.name.charAt(0)}`
            }));

            // Start the actual game
            initializeMultiplayerGame(gameData.gameState);
        }

        async function initializeMultiplayerGame(initialGameState) {
            deck = initialGameState.deck;
            discardPile = initialGameState.discardPile;
            drawPile = [...deck];
            currentPlayerIndex = initialGameState.currentPlayerIndex;
            activeStack = initialGameState.activeStack;
            whotRequest = initialGameState.whotRequest;
            holdOnActive = initialGameState.holdOnActive;
            turnsToSkip = initialGameState.turnsToSkip;
            generalMarketState = initialGameState.generalMarketState;
            eliminatedPlayers = initialGameState.eliminatedPlayers || [];

            updateStatus("Dealing cards...");
            renderGame();

            // Deal initial cards
            for (let i = 0; i < 6; i++) {
                for(let j = 0; j < players.length; j++) {
                    if (eliminatedPlayers.includes(j)) continue;
                    await dealCardToPlayer(j);
                }
            }
            
            // Set first discard card
            let firstCardIndex = drawPile.findIndex(card => !ACTION_CARDS.includes(card.number));
            if (firstCardIndex === -1) { firstCardIndex = 0; }
            discardPile = [drawPile.splice(firstCardIndex, 1)[0]];
            
            renderGame();
            updateStatusMessage();

            // Set up real-time sync
            setupMultiplayerSync();
        }

        function setupMultiplayerSync() {
            const gameStateRef = window.firebase.ref(window.firebase.database, `games/${currentGameId}/gameState`);
            window.firebase.onValue(gameStateRef, (snapshot) => {
                const serverGameState = snapshot.val();
                if (serverGameState && gameMode === 'multiplayer') {
                    syncGameState(serverGameState);
                }
            });
        }

        function syncGameState(serverState) {
            discardPile = serverState.discardPile || [];
            currentPlayerIndex = serverState.currentPlayerIndex || 0;
            activeStack = serverState.activeStack;
            whotRequest = serverState.whotRequest;
            holdOnActive = serverState.holdOnActive || false;
            turnsToSkip = serverState.turnsToSkip || 0;
            generalMarketState = serverState.generalMarketState || { active: false, initiator: null, respondedMask: [], playersWhoPlayed: [] };
            eliminatedPlayers = serverState.eliminatedPlayers || [];

            // Sync players' hands
            if (serverState.players) {
                players.forEach((player, index) => {
                    const serverPlayer = serverState.players[player.id];
                    if (serverPlayer) {
                        if (player.isHuman) {
                            player.regularHand = serverPlayer.regularHand || [];
                            player.actionHand = serverPlayer.actionHand || [];
                        } else {
                            player.hand = serverPlayer.hand || [];
                        }
                    }
                });
            }

            renderGame();
            updateStatusMessage();

            // Check for win condition
            if (serverState.winner) {
                handleGameEnd(serverState);
            }
        }

        async function updateServerGameState(updates) {
            if (gameMode !== 'multiplayer' || !currentGameId) return;

            try {
                const gameStateRef = window.firebase.ref(window.firebase.database, `games/${currentGameId}/gameState`);
                
                // Prepare player data for server
                const playersData = {};
                players.forEach(player => {
                    playersData[player.id] = {
                        id: player.id,
                        name: player.name,
                        regularHand: player.regularHand || [],
                        actionHand: player.actionHand || [],
                        hand: player.hand || []
                    };
                });

                const fullUpdate = {
                    ...updates,
                    players: playersData,
                    updatedAt: window.firebase.serverTimestamp()
                };

                await window.firebase.set(gameStateRef, fullUpdate);
            } catch (error) {
                console.error('Error updating server game state:', error);
            }
        }

        // Single Player Setup
        const playerCountDisplay = document.getElementById('player-count-display');
        const decrementBtn = document.getElementById('decrement-players');
        const incrementBtn = document.getElementById('increment-players');
        const startSingleGameBtn = document.getElementById('start-single-game-btn');

        decrementBtn.addEventListener('click', () => {
            let count = parseInt(playerCountDisplay.textContent);
            if (count > 1) {
                playerCountDisplay.textContent = count - 1;
            }
        });

        incrementBtn.addEventListener('click', () => {
            let count = parseInt(playerCountDisplay.textContent);
            if (count < 5) {
                playerCountDisplay.textContent = count + 1;
            }
        });

        startSingleGameBtn.addEventListener('click', () => {
            const numBots = parseInt(playerCountDisplay.textContent);
            initializeSinglePlayerGame(numBots);
        });

        function initializeSinglePlayerGame(numBots) {
            players = [];
            players.push({ id: 'human', name: 'You', isHuman: true, regularHand: [], actionHand: [] });
            for (let i = 0; i < numBots; i++) {
                const botName = generateBotName();
                players.push({
                    id: `bot${i+1}`,
                    name: botName,
                    isHuman: false,
                    hand: [],
                    avatar: `https://placehold.co/50x50/4a5568/ffffff?text=${botName.charAt(0)}`
                });
            }
            eliminatedPlayers = [];
            setupScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            gameContainer.classList.add('flex');
            startGame();
        }

        function generateBotName() {
            return BOT_NAMES[Math.floor(Math.random() * BOT_NAMES.length)];
        }

        // Game Logic Functions (Modified for multiplayer support)
        function createDeck() {
            const deck = [];
            const cardDistribution = {
                circle:   [1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 13, 14],
                triangle: [1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 13, 14],
                square:   [1, 2, 3, 5, 7, 10, 11, 13, 14],
                cross:    [1, 2, 3, 5, 7, 10, 11, 13, 14],
                star:     [1, 2, 3, 4, 5, 7, 8]
            };
            for (const shape in cardDistribution) {
                for (const number of cardDistribution[shape]) {
                    deck.push({ shape, number });
                }
            }
            for (let i = 0; i < 5; i++) {
                deck.push({ shape: 'whot', number: 20 });
            }
            return deck;
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        async function startGame() {
            deck = createDeck();
            shuffleDeck(deck);
            discardPile = [];
            drawPile = deck;

            players.forEach(p => {
                if (eliminatedPlayers.includes(players.indexOf(p))) return;
                if (p.isHuman) {
                    p.regularHand = [];
                    p.actionHand = [];
                } else {
                    p.hand = [];
                }
            });

            const existingWinnerMessage = document.querySelector('.winner-message');
            if (existingWinnerMessage) existingWinnerMessage.remove();
            
            updateStatus("Shuffling...");
            renderGame();
            await new Promise(r => setTimeout(r, 800));

            for (let i = 0; i < 6; i++) {
                for(let j = 0; j < players.length; j++) {
                    if (eliminatedPlayers.includes(j)) continue;
                    await dealCardToPlayer(j);
                }
            }
            
            let firstCardIndex = drawPile.findIndex(card => !ACTION_CARDS.includes(card.number));
            if (firstCardIndex === -1) { firstCardIndex = 0; }
            discardPile = [drawPile.splice(firstCardIndex, 1)[0]];
            
            activeStack = null;
            whotRequest = null;
            holdOnActive = false;
            turnsToSkip = 0;
            currentPlayerIndex = findNextActivePlayer(0);
            generalMarketState = { active: false, initiator: null, respondedMask: [], playersWhoPlayed: [] };
            
            renderGame();
            updateStatusMessage();

            if (gameMode === 'multiplayer') {
                await updateServerGameState({
                    discardPile,
                    currentPlayerIndex,
                    activeStack,
                    whotRequest,
                    holdOnActive,
                    turnsToSkip,
                    generalMarketState,
                    eliminatedPlayers
                });
            }
        }

        function findNextActivePlayer(startIndex) {
            for (let i = 0; i < players.length; i++) {
                const index = (startIndex + i) % players.length;
                if (!eliminatedPlayers.includes(index)) {
                    return index;
                }
            }
            return startIndex; // Fallback
        }

        // Card calculation for counting mode
        function calculateCardValue(card) {
            if (card.number === 20) return 20; // Whot card
            if ([1, 2, 5, 8, 14].includes(card.number)) return 20; // Action cards
            return card.number;
        }

        function calculateHandTotal(player) {
            const allCards = player.isHuman ? 
                [...(player.regularHand || []), ...(player.actionHand || [])] : 
                (player.hand || []);
            return allCards.reduce((total, card) => total + calculateCardValue(card), 0);
        }

        async function checkWinCondition(playerIndex) {
            const player = players[playerIndex];
            const hand = player.isHuman ? [...player.regularHand, ...player.actionHand] : player.hand;
            
            if (hand.length > 0) return false; // Player hasn't won yet

            const activePlayers = players.filter((_, i) => !eliminatedPlayers.includes(i));
            
            if (gameType === 'counting') {
                // Counting Cards Mode
                if (activePlayers.length <= 2) {
                    // Only 2 players left, winner is determined
                    const otherPlayerIndex = players.findIndex((_, i) => i !== playerIndex && !eliminatedPlayers.includes(i));
                    if (otherPlayerIndex !== -1) {
                        await eliminatePlayer(otherPlayerIndex);
                        endGame(player);
                        return true;
                    }
                } else {
                    // More than 2 players, eliminate the one with highest card total
                    let highestTotal = 0;
                    let playerToEliminate = -1;
                    
                    players.forEach((p, i) => {
                        if (i !== playerIndex && !eliminatedPlayers.includes(i)) {
                            const total = calculateHandTotal(p);
                            if (total > highestTotal) {
                                highestTotal = total;
                                playerToEliminate = i;
                            }
                        }
                    });
                    
                    if (playerToEliminate !== -1) {
                        await eliminatePlayer(playerToEliminate);
                        
                        // Check if only one player remains
                        const remainingPlayers = players.filter((_, i) => !eliminatedPlayers.includes(i));
                        if (remainingPlayers.length === 1) {
                            endGame(remainingPlayers[0]);
                            return true;
                        } else {
                            showToast(`${players[playerToEliminate].name} eliminated! Starting new round...`, 'info');
                            setTimeout(() => startGame(), 2000);
                            return true;
                        }
                    }
                }
            } else {
                // Elimination Mode (Last Standing)
                const remainingPlayers = players.filter((_, i) => !eliminatedPlayers.includes(i));
                if (remainingPlayers.length === 1) {
                    // This is the last player standing, eliminate them and end tournament
                    await eliminatePlayer(playerIndex);
                    endGame(null, true); // Tournament winner
                    return true;
                } else {
                    showToast(`${player.name} finished! Starting new round...`, 'success');
                    setTimeout(() => startGame(), 2000);
                    return true;
                }
            }
            
            return false;
        }

        async function eliminatePlayer(playerIndex) {
            if (!eliminatedPlayers.includes(playerIndex)) {
                eliminatedPlayers.push(playerIndex);
                renderEliminatedBar();
                
                if (gameMode === 'multiplayer') {
                    await updateServerGameState({
                        discardPile,
                        currentPlayerIndex,
                        activeStack,
                        whotRequest,
                        holdOnActive,
                        turnsToSkip,
                        generalMarketState,
                        eliminatedPlayers
                    });
                }
            }
        }

        function renderEliminatedBar() {
            const eliminatedBar = document.getElementById('eliminated-bar');
            const eliminatedText = document.getElementById('eliminated-text');
            
            if (eliminatedPlayers.length > 0) {
                const eliminatedNames = eliminatedPlayers.map(i => players[i].name).join(', ');
                eliminatedText.textContent = `Eliminated: ${eliminatedNames}`;
                eliminatedBar.classList.remove('hidden');
            } else {
                eliminatedBar.classList.add('hidden');
            }
        }

        // Rest of the existing game logic continues...
        // (I'll include the remaining functions in the next part due to length constraints)

        // DOM element references
        const leftHandDiv = document.getElementById('left-hand');
        const rightHandDiv = document.getElementById('right-hand');
        const computerPlayersArea = document.getElementById('computer-players-area');
        const discardPileDiv = document.getElementById('discard-pile');
        const drawPileDiv = document.getElementById('draw-pile');
        const gameStatusDiv = document.getElementById('game-status');
        const shapeModal = document.getElementById('shape-modal');
        const shapeOptionsDiv = document.getElementById('shape-options');
        const leftPushButtonsDiv = document.getElementById('left-push-buttons');
        const rightPushButtonsDiv = document.getElementById('right-push-buttons');

        // Rendering functions
        function createCardElement(card, isFaceUp = true, cardIndex = -1, handName = '') {
            const cardDiv = document.createElement('div');
            if (!isFaceUp) {
                cardDiv.className = 'card card-back';
                cardDiv.innerHTML = `<div class="whot-text-back">Whot</div><div class="whot-text-back" style="transform: rotate(180deg);">Whot</div>`;
                return cardDiv;
            }
            cardDiv.className = 'card';
            const { shape, number } = card;
            if (shape === 'whot') {
                cardDiv.innerHTML = `
                    <div class="corner top-left"><span>20</span></div>
                    <div class="whot-card-center">
                        <div class="whot-text">Whot</div>
                        <div class="whot-text" style="transform: rotate(180deg);">Whot</div>
                    </div>
                    <div class="corner bottom-right"><span>20</span></div>
                `;
            } else {
                const shapeSVG = SHAPES_SVG[shape];
                cardDiv.innerHTML = `
                    <div class="corner top-left">
                        <span>${number}</span>
                        <div class="corner-shape">${shapeSVG}</div>
                    </div>
                    <div class="card-symbol">${shapeSVG}</div>
                    <div class="corner bottom-right">
                        <span>${number}</span>
                        <div class="corner-shape">${shapeSVG}</div>
                    </div>
                `;
            }

            if (handName === 'regular' || handName === 'action') {
                cardDiv.draggable = true;
                cardDiv.dataset.cardIndex = cardIndex;
                cardDiv.dataset.handName = handName;
                
                cardDiv.addEventListener('dragstart', (e) => handleDragStart(e, card, handName, cardIndex));
                cardDiv.addEventListener('dragend', (e) => handleDragEnd(e));
                cardDiv.addEventListener('click', (e) => {
                    if (!isDragging) {
                        handleCardClick(card, handName);
                    }
                });
            }
            
            return cardDiv;
        }
        
        function renderVisualStack(container, cardCount) {
            container.innerHTML = '';
            const maxVisibleCards = 20; 
            const stackSize = Math.min(cardCount, maxVisibleCards);
            if (cardCount > 0) {
                for (let i = 0; i < stackSize; i++) {
                    const cardEl = createCardElement(null, false);
                    cardEl.style.transform = `translateY(${i * 2}px)`;
                    cardEl.style.zIndex = i;
                    container.appendChild(cardEl);
                }
            }
        }

        function renderHand(handArray, containerDiv, handName) {
            containerDiv.innerHTML = '';
            const totalCards = handArray.length;
            const cardWidth = window.innerWidth <= 1024 ? 90 : 120;
            const overlap = window.innerWidth <= 1024 ? 35 : 50;
            const totalWidth = cardWidth + (totalCards > 0 ? (totalCards - 1) * overlap : 0);
            
            handArray.forEach((card, i) => {
                const cardEl = createCardElement(card, true, i, handName);
                const xOffset = (i * overlap) - (totalWidth / 2) + (cardWidth / 2);
                cardEl.style.transform = `translateX(${xOffset}px)`;
                cardEl.style.zIndex = i;
                containerDiv.appendChild(cardEl);
            });
        }

        function renderGame() {
            if (players.length === 0) return;
            
            const humanPlayer = players.find(p => p.isHuman);
            if (humanPlayer) {
                humanPlayer.regularHand.sort((a, b) => a.number - b.number);
                humanPlayer.actionHand.sort((a, b) => a.number - b.number);
                
                renderHand(humanPlayer.regularHand, leftHandDiv, 'regular');
                renderHand(humanPlayer.actionHand, rightHandDiv, 'action');
                renderPushButtons();
            }

            computerPlayersArea.innerHTML = '';
            players.forEach((player, index) => {
                if (!player.isHuman) {
                    const profileDiv = document.createElement('div');
                    profileDiv.className = 'computer-player-profile';
                    
                    // Add eliminated styling
                    if (eliminatedPlayers.includes(index)) {
                        profileDiv.classList.add('eliminated');
                    }
                    
                    if (index === currentPlayerIndex && !generalMarketState.active && !eliminatedPlayers.includes(index)) {
                        profileDiv.classList.add('active-turn');
                    }
                    
                    profileDiv.innerHTML = `
                        <img src="${player.avatar}" alt="Bot Avatar" class="bot-avatar">
                        <div class="text-base font-semibold">${player.name}</div>
                    `;
                    
                    const handContainer = document.createElement('div');
                    handContainer.className = 'card-stack-container';
                    renderVisualStack(handContainer, player.hand.length);
                    
                    profileDiv.appendChild(handContainer);
                    computerPlayersArea.appendChild(profileDiv);
                }
            });

            discardPileDiv.innerHTML = '';
            if (discardPile.length > 0) {
                const cardsToShow = discardPile.slice(-5);
                const overlap = 25;
                const cardWidth = window.innerWidth <= 1024 ? 90 : 120;
                const totalWidth = cardWidth + (cardsToShow.length > 1 ? (cardsToShow.length - 1) * overlap : 0);
                
                const containerWidth = discardPileDiv.offsetWidth;
                const groupStartX = (containerWidth - totalWidth) / 2;

                cardsToShow.forEach((card, i) => {
                    const cardEl = createCardElement(card, true);
                    cardEl.style.position = 'absolute';
                    const xOffset = groupStartX + (i * overlap);
                    const yOffset = i * 2;
                    cardEl.style.left = `${xOffset}px`;
                    cardEl.style.top = `${yOffset}px`;
                    cardEl.style.zIndex = i;
                    discardPileDiv.appendChild(cardEl);
                });
            }
           
            renderVisualStack(drawPileDiv, drawPile.length);
            renderEliminatedBar();
            updateStatusMessage();
        }

        function renderPushButtons() {
            leftPushButtonsDiv.innerHTML = '';
            rightPushButtonsDiv.innerHTML = '';

            const humanPlayerIndex = players.findIndex(p => p.isHuman);
            if (currentPlayerIndex !== humanPlayerIndex || eliminatedPlayers.includes(humanPlayerIndex)) return;

            const humanPlayer = players[humanPlayerIndex];

            const findPlayablePushableGroups = (hand) => {
                const counts = hand.reduce((acc, card) => {
                    acc[card.number] = (acc[card.number] || 0) + 1;
                    return acc;
                }, {});
                
                return Object.keys(counts)
                    .map(Number)
                    .filter(num => {
                        const cardsWithNum = hand.filter(c => c.number === num);
                        return counts[num] > 1 && cardsWithNum.some(card => isCardPlayable(card));
                    });
            };

            const regularGroups = findPlayablePushableGroups(humanPlayer.regularHand);
            const actionGroups = findPlayablePushableGroups(humanPlayer.actionHand);

            regularGroups.forEach(num => {
                const button = document.createElement('button');
                button.className = 'push-button';
                button.textContent = `Push ${num}s`;
                button.onclick = () => playPushGroup(num, 'regular');
                leftPushButtonsDiv.appendChild(button);
            });

            actionGroups.forEach(num => {
                const button = document.createElement('button');
                button.className = 'push-button';
                button.textContent = `Push ${num}s`;
                button.onclick = () => playPushGroup(num, 'action');
                rightPushButtonsDiv.appendChild(button);
            });
        }

        function updateStatus(message) {
             gameStatusDiv.innerHTML = `<div>${message}</div>`;
             gameStatusDiv.style.visibility = 'visible';
        }

        function updateStatusMessage() {
            if (players.length === 0) return;
            gameStatusDiv.innerHTML = '';
            gameStatusDiv.style.visibility = 'hidden';
        }
        
        function showToast(message, type = 'info') {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            let bgColor = 'bg-blue-500';
            if (type === 'error') bgColor = 'bg-red-500';
            if (type === 'success') bgColor = 'bg-green-500';

            toast.className = `toast text-white px-6 py-3 rounded-lg shadow-lg ${bgColor}`;
            toast.textContent = message;
            
            toastContainer.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // Game logic functions (continued)
        async function dealCardToPlayer(playerIndex) {
            if (drawPile.length === 0) {
                if (!reshuffleDiscardPile()) {
                    showToast("Market is empty!", "error");
                    return;
                }
                renderGame();
                await new Promise(r => setTimeout(r, 200));
            }
            
            const player = players[playerIndex];
            const card = drawPile[drawPile.length - 1]; 
            
            if (player.isHuman) {
                const targetDiv = ACTION_CARDS.includes(card.number) ? rightHandDiv : leftHandDiv;
                const hand = ACTION_CARDS.includes(card.number) ? player.actionHand : player.regularHand;
                await dealCard(hand, targetDiv);
            } else {
                const targetDiv = document.querySelector(`#computer-players-area .computer-player-profile:nth-child(${playerIndex}) .card-stack-container`);
                await dealCard(player.hand, targetDiv);
            }
        }

        async function dealCard(handArray, targetDiv) {
            if (drawPile.length === 0) return;

            await animateCardDraw(targetDiv);
            handArray.push(drawPile.pop());

            if (drawPile.length === 0) {
                reshuffleDiscardPile();
            }
            renderGame(); 
        }

        function isCardPlayable(card) {
            if (generalMarketState.active) {
                return card.number === 14;
            }
            if (discardPile.length === 0) return false;
            const topCard = discardPile[discardPile.length - 1];
            if (card.number === 20) return true;
            if (whotRequest) return card.shape === whotRequest.shape;
            if (activeStack) return card.number === activeStack.card || card.number === 20;
            if (holdOnActive) return card.number === 1 || card.shape === topCard.shape;
            return card.shape === topCard.shape || card.number === topCard.number;
        }
        
        function reshuffleDiscardPile() {
            if (discardPile.length <= 1) return false;
            const topCard = discardPile.pop();
            drawPile = [...discardPile];
            shuffleDeck(drawPile);
            discardPile = [topCard];
            return true;
        }

        // Drag and drop handlers
        function handleDragStart(event, card, handName, cardIndex) {
            draggedCardData = { card, handName, cardIndex };
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', 'card'); 
            event.target.classList.add('dragging');
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 1;
            const ctx = canvas.getContext('2d');
            ctx.globalAlpha = 0;
            ctx.fillRect(0, 0, 1, 1);
            event.dataTransfer.setDragImage(canvas, 0, 0);
            setTimeout(() => {
                document.querySelectorAll('#left-hand, #right-hand, #discard-pile').forEach(el => {
                    el.style.pointerEvents = 'auto';
                });
            }, 10);
        }

        function handleDragEnd(event) {
            event.target.classList.remove('dragging');
            document.querySelectorAll('.drop-zone').forEach(el => {
                el.classList.remove('drop-zone');
            });
            draggedCardData = null;
        }

        function handleDragOver(event) {
            if (draggedCardData) {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
            }
        }

        function handleDragEnter(event) {
            if (draggedCardData) {
                event.preventDefault();
                event.currentTarget.classList.add('drop-zone');
            }
        }

        function handleDragLeave(event) {
            const rect = event.currentTarget.getBoundingClientRect();
            const x = event.clientX;
            const y = event.clientY;
            if (x <= rect.left || x >= rect.right || y <= rect.top || y >= rect.bottom) {
                event.currentTarget.classList.remove('drop-zone');
            }
        }

        function handleDropOnHand(event, targetHandName) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.remove('drop-zone');
            if (!draggedCardData) return;

            const { card, handName: sourceHandName } = draggedCardData;
            const humanPlayer = players.find(p => p.isHuman);
            let sourceHand = sourceHandName === 'regular' ? humanPlayer.regularHand : humanPlayer.actionHand;
            let targetHand = targetHandName === 'regular' ? humanPlayer.regularHand : humanPlayer.actionHand;
            
            const cardIndex = sourceHand.findIndex(c => c.shape === card.shape && c.number === card.number);
            if (cardIndex !== -1) {
                const [removedCard] = sourceHand.splice(cardIndex, 1);
                targetHand.push(removedCard);
                renderGame();
            }
        }

        function handleDropOnDiscardPile(event) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.remove('drop-zone');
            if (!draggedCardData) return;

            const { card, handName } = draggedCardData;
            
            const humanPlayerIndex = players.findIndex(p => p.isHuman);
            if ((generalMarketState.active && card.number !== 14) || 
                (!generalMarketState.active && currentPlayerIndex !== humanPlayerIndex)) {
                return;
            }
            
            if (!isCardPlayable(card)) return;

            const humanPlayer = players[humanPlayerIndex];
            let sourceHand = handName === 'regular' ? humanPlayer.regularHand : humanPlayer.actionHand;
            const cardIndex = sourceHand.findIndex(c => c.shape === card.shape && c.number === card.number);
            
            if (cardIndex !== -1) {
                sourceHand.splice(cardIndex, 1);
                renderGame();
                animateCardPlayFromPosition(card, null, handName).then(async () => {
                    if (generalMarketState.active && card.number === 14) {
                        generalMarketState.playersWhoPlayed.push(humanPlayerIndex);
                        generalMarketState.respondedMask[humanPlayerIndex] = true;
                        discardPile.push(card);
                        renderGame();
                        
                        if (gameMode === 'multiplayer') {
                            await updateServerGameState({
                                discardPile,
                                currentPlayerIndex,
                                activeStack,
                                whotRequest,
                                holdOnActive,
                                turnsToSkip,
                                generalMarketState,
                                eliminatedPlayers
                            });
                        }
                        
                        checkIfMarketIsOver();
                    } else {
                        await playCard(card, humanPlayerIndex);
                    }
                });
            }
        }

        function setupDragAndDrop() {
            leftHandDiv.addEventListener('dragover', handleDragOver);
            leftHandDiv.addEventListener('dragenter', handleDragEnter);
            leftHandDiv.addEventListener('dragleave', handleDragLeave);
            leftHandDiv.addEventListener('drop', (e) => handleDropOnHand(e, 'regular'));

            rightHandDiv.addEventListener('dragover', handleDragOver);
            rightHandDiv.addEventListener('dragenter', handleDragEnter);
            rightHandDiv.addEventListener('dragleave', handleDragLeave);
            rightHandDiv.addEventListener('drop', (e) => handleDropOnHand(e, 'action'));

            discardPileDiv.addEventListener('dragover', handleDragOver);
            discardPileDiv.addEventListener('dragenter', (e) => {
                if (draggedCardData && isCardPlayable(draggedCardData.card)) {
                    const humanPlayerIndex = players.findIndex(p => p.isHuman);
                     if (generalMarketState.active || currentPlayerIndex === humanPlayerIndex) {
                        e.preventDefault();
                        e.currentTarget.classList.add('drop-zone');
                    }
                }
            });
            discardPileDiv.addEventListener('dragleave', handleDragLeave);
            discardPileDiv.addEventListener('drop', handleDropOnDiscardPile);
        }

        async function handleCardClick(card, handName) {
            if (isDragging) return;

            const humanPlayerIndex = players.findIndex(p => p.isHuman);

            if (generalMarketState.active) {
                if (card.number === 14) {
                    generalMarketState.playersWhoPlayed.push(humanPlayerIndex);
                    generalMarketState.respondedMask[humanPlayerIndex] = true;

                    const humanPlayer = players[humanPlayerIndex];
                    const hand = handName === 'regular' ? humanPlayer.regularHand : humanPlayer.actionHand;
                    const cardIndex = hand.findIndex(c => c.shape === card.shape && c.number === card.number);
                    if (cardIndex !== -1) hand.splice(cardIndex, 1);
                    
                    await animateCardPlayFromPosition(card, null, handName);
                    discardPile.push(card);
                    renderGame();
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({
                            discardPile,
                            currentPlayerIndex,
                            activeStack,
                            whotRequest,
                            holdOnActive,
                            turnsToSkip,
                            generalMarketState,
                            eliminatedPlayers
                        });
                    }
                    
                    checkIfMarketIsOver();
                }
                return;
            }
            
            if (currentPlayerIndex !== humanPlayerIndex || !isCardPlayable(card)) return;
            
            const humanPlayer = players[humanPlayerIndex];
            let startRect = null; 
            
            const hand = handName === 'regular' ? humanPlayer.regularHand : humanPlayer.actionHand;
            const cardIndex = hand.findIndex(c => c.shape === card.shape && c.number === card.number);
            if (cardIndex !== -1) hand.splice(cardIndex, 1);
            
            renderGame();
            await animateCardPlayFromPosition(card, startRect, handName);
            await playCard(card, humanPlayerIndex);
        }

        async function playPushGroup(number, handName) {
            const humanPlayerIndex = players.findIndex(p => p.isHuman);
            if (currentPlayerIndex !== humanPlayerIndex) return;

            const humanPlayer = players[humanPlayerIndex];
            let sourceHand = handName === 'regular' ? humanPlayer.regularHand : humanPlayer.actionHand;
            
            const cardsToPlay = sourceHand.filter(c => c.number === number);
            if (cardsToPlay.length < 2 || !cardsToPlay.some(isCardPlayable)) {
                return;
            }

            if (handName === 'regular') {
                humanPlayer.regularHand = sourceHand.filter(c => c.number !== number);
            } else {
                humanPlayer.actionHand = sourceHand.filter(c => c.number !== number);
            }
            renderGame();

            for (const card of cardsToPlay) {
                await animateCardPlayFromPosition(card, null, handName);
                discardPile.push(card);
                renderGame();
                await new Promise(r => setTimeout(r, 100));
            }

            const lastCard = cardsToPlay[cardsToPlay.length - 1];
            const numPlayed = cardsToPlay.length;

            // Check win condition first
            const hasWon = await checkWinCondition(humanPlayerIndex);
            if (hasWon) return;

            whotRequest = null;
            if (lastCard.number !== 1) holdOnActive = false;

            if (gameMode === 'multiplayer') {
                await updateServerGameState({
                    discardPile,
                    currentPlayerIndex,
                    activeStack,
                    whotRequest,
                    holdOnActive,
                    turnsToSkip,
                    generalMarketState,
                    eliminatedPlayers
                });
            }

            switch (lastCard.number) {
                case 1: 
                    renderGame();
                    break;
                case 14:
                    generalMarketState.active = true;
                    generalMarketState.initiator = humanPlayerIndex;
                    generalMarketState.respondedMask = players.map((_, i) => i === humanPlayerIndex);
                    generalMarketState.playersWhoPlayed = [humanPlayerIndex];
                    renderGame();
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({
                            discardPile,
                            currentPlayerIndex,
                            activeStack,
                            whotRequest,
                            holdOnActive,
                            turnsToSkip,
                            generalMarketState,
                            eliminatedPlayers
                        });
                    }
                    
                    players.forEach((p, i) => {
                        if (!p.isHuman && !eliminatedPlayers.includes(i)) respondToMarketAsBot(i);
                    });
                    break;
                case 8: 
                    turnsToSkip = numPlayed;
                    endTurn();
                    break;
                case 20: 
                    if (activeStack) { activeStack = null; }
                    requestShapeFromPlayer();
                    break;
                case 2: case 5: 
                    const penaltyCardNumber = lastCard.number;
                    if (activeStack && activeStack.card === penaltyCardNumber) {
                        activeStack.count += numPlayed;
                    } else {
                        activeStack = { card: penaltyCardNumber, count: numPlayed };
                    }
                    renderGame();
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({
                            discardPile,
                            currentPlayerIndex,
                            activeStack,
                            whotRequest,
                            holdOnActive,
                            turnsToSkip,
                            generalMarketState,
                            eliminatedPlayers
                        });
                    }
                    
                    endTurn();
                    break;
                default:
                    endTurn();
                    break;
            }
        }

        async function playCard(card, playerIdx) {
            discardPile.push(card);
            whotRequest = null;
            if (card.number !== 1) holdOnActive = false;

            // Check win condition first
            const hasWon = await checkWinCondition(playerIdx);
            if (hasWon) return;

            renderGame();
            
            if (gameMode === 'multiplayer') {
                await updateServerGameState({
                    discardPile,
                    currentPlayerIndex,
                    activeStack,
                    whotRequest,
                    holdOnActive,
                    turnsToSkip,
                    generalMarketState,
                    eliminatedPlayers
                });
            }
            
            await applyCardEffect(card, playerIdx);
        }

        async function applyCardEffect(card, playerIdx) {
            let shouldEndTurn = true;

            switch (card.number) {
                case 1:
                    shouldEndTurn = false;
                    if (players[playerIdx].isHuman) {
                        renderGame();
                    } else {
                        setTimeout(() => botTurn(), 1000);
                    }
                    break;
                case 14:
                    shouldEndTurn = false;
                    if (generalMarketState.active) return;

                    generalMarketState.active = true;
                    generalMarketState.initiator = playerIdx;
                    generalMarketState.respondedMask = players.map(() => false);
                    generalMarketState.respondedMask[playerIdx] = true;
                    generalMarketState.playersWhoPlayed = [playerIdx];
                    
                    renderGame();
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({
                            discardPile,
                            currentPlayerIndex,
                            activeStack,
                            whotRequest,
                            holdOnActive,
                            turnsToSkip,
                            generalMarketState,
                            eliminatedPlayers
                        });
                    }
                    
                    players.forEach((p, i) => {
                        if (i !== playerIdx && !eliminatedPlayers.includes(i)) {
                           if (p.isHuman) {
                               // wait for human input
                           } else {
                               respondToMarketAsBot(i);
                           }
                        }
                    });
                    break;
                case 8:
                    turnsToSkip = 1;
                    break;
                case 20:
                    if (activeStack) { activeStack = null; }
                    if (players[playerIdx].isHuman) {
                        requestShapeFromPlayer();
                        shouldEndTurn = false;
                    } else {
                        const chosenShape = chooseBestShapeForBot(players[playerIdx]);
                        whotRequest = { shape: chosenShape };
                        const topCard = discardPile[discardPile.length - 1];
                        if (topCard && topCard.number === 20) {
                            topCard.shape = chosenShape;
                        }
                        renderGame();
                        
                        if (gameMode === 'multiplayer') {
                            await updateServerGameState({
                                discardPile,
                                currentPlayerIndex,
                                activeStack,
                                whotRequest,
                                holdOnActive,
                                turnsToSkip,
                                generalMarketState,
                                eliminatedPlayers
                            });
                        }
                    }
                    break;
                case 2: case 5:
                    if (activeStack && activeStack.card === card.number) {
                        activeStack.count++;
                    } else {
                        activeStack = { card: card.number, count: 1 };
                    }
                    renderGame();
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({
                            discardPile,
                            currentPlayerIndex,
                            activeStack,
                            whotRequest,
                            holdOnActive,
                            turnsToSkip,
                            generalMarketState,
                            eliminatedPlayers
                        });
                    }
                    break;
            }

            if (shouldEndTurn) {
                endTurn();
            }
        }

        async function endTurn() {
            let nextPlayerIndex = (currentPlayerIndex + 1 + turnsToSkip) % players.length;
            turnsToSkip = 0;
            
            // Skip eliminated players
            nextPlayerIndex = findNextActivePlayer(nextPlayerIndex);
            currentPlayerIndex = nextPlayerIndex;
            
            if (gameMode === 'multiplayer') {
                await updateServerGameState({
                    discardPile,
                    currentPlayerIndex,
                    activeStack,
                    whotRequest,
                    holdOnActive,
                    turnsToSkip,
                    generalMarketState,
                    eliminatedPlayers
                });
            }
            
            setTimeout(() => {
                renderGame();
                if (!players[currentPlayerIndex].isHuman && !eliminatedPlayers.includes(currentPlayerIndex)) {
                    botTurn();
                }
            }, 800);
        }

        async function handlePlayerDraw() {
            const humanPlayerIndex = players.findIndex(p => p.isHuman);
            
            if (generalMarketState.active) {
                if (currentPlayerIndex === humanPlayerIndex && !generalMarketState.respondedMask[humanPlayerIndex]) {
                    generalMarketState.respondedMask[humanPlayerIndex] = true;
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({
                            discardPile,
                            currentPlayerIndex,
                            activeStack,
                            whotRequest,
                            holdOnActive,
                            turnsToSkip,
                            generalMarketState,
                            eliminatedPlayers
                        });
                    }
                    
                    checkIfMarketIsOver();
                }
                return;
            }
            
            if (currentPlayerIndex !== humanPlayerIndex) return;

            holdOnActive = false;

            if (activeStack) {
                const penalty = activeStack.card === 2 ? 2 : 3;
                const totalCards = activeStack.count * penalty;
                for(let i = 0; i < totalCards; i++) await dealCardToPlayer(currentPlayerIndex);
                activeStack = null;
            } else {
                await dealCardToPlayer(currentPlayerIndex);
            }
            renderGame();
            
            if (gameMode === 'multiplayer') {
                await updateServerGameState({
                    discardPile,
                    currentPlayerIndex,
                    activeStack,
                    whotRequest,
                    holdOnActive,
                    turnsToSkip,
                    generalMarketState,
                    eliminatedPlayers
                });
            }
            
            endTurn();
        }

        // Bot AI functions
        async function botTurn() {
            updateStatusMessage();
            await new Promise(r => setTimeout(r, 1200));
            
            const bot = players[currentPlayerIndex];

            if (activeStack) {
                const whotCard = bot.hand.find(c => c.number === 20);
                if (whotCard) {
                    bot.hand = bot.hand.filter(c => c !== whotCard);
                    await animateCardPlayFromComputer(whotCard);
                    await playCard(whotCard, currentPlayerIndex);
                    return;
                }
                const counterCard = bot.hand.find(c => c.number === activeStack.card);
                if (counterCard) {
                    bot.hand = bot.hand.filter(c => c !== counterCard);
                    await animateCardPlayFromComputer(counterCard);
                    await playCard(counterCard, currentPlayerIndex);
                    return;
                } else {
                    const penalty = activeStack.card === 2 ? 2 : 3;
                    const totalCards = activeStack.count * penalty;
                    for(let i = 0; i < totalCards; i++) await dealCardToPlayer(currentPlayerIndex);
                    activeStack = null;
                    
                    if (gameMode === 'multiplayer') {
                        await updateServerGameState({
                            discardPile,
                            currentPlayerIndex,
                            activeStack,
                            whotRequest,
                            holdOnActive,
                            turnsToSkip,
                            generalMarketState,
                            eliminatedPlayers
                        });
                    }
                    
                    endTurn();
                    return;
                }
            }

            const playableCards = bot.hand.filter(c => isCardPlayable(c));
            if (playableCards.length > 0) {
                const specialCard = playableCards.find(c => [1, 2, 5, 8, 14, 20].includes(c.number));
                let cardToPlay = specialCard || playableCards[0];
                
                bot.hand = bot.hand.filter(c => c !== cardToPlay);
                await animateCardPlayFromComputer(cardToPlay);
                await playCard(cardToPlay, currentPlayerIndex);
            } else {
                holdOnActive = false;
                await dealCardToPlayer(currentPlayerIndex);
                
                if (gameMode === 'multiplayer') {
                    await updateServerGameState({
                        discardPile,
                        currentPlayerIndex,
                        activeStack,
                        whotRequest,
                        holdOnActive,
                        turnsToSkip,
                        generalMarketState,
                        eliminatedPlayers
                    });
                }
                
                endTurn();
            }
        }

        function chooseBestShapeForBot(bot) {
            const shapeCounts = {};
            bot.hand.forEach(card => {
                if (card.shape !== 'whot') shapeCounts[card.shape] = (shapeCounts[card.shape] || 0) + 1;
            });
            let bestShape = 'circle', maxCount = 0;
            for (const shape in shapeCounts) {
                if (shapeCounts[shape] > maxCount) { maxCount = shapeCounts[shape]; bestShape = shape; }
            }
            return bestShape;
        }

        // General Market functions
        function respondToMarketAsBot(botIndex) {
            if (eliminatedPlayers.includes(botIndex)) return;
            
            setTimeout(async () => {
                const bot = players[botIndex];
                const marketCard = bot.hand.find(c => c.number === 14);

                if (marketCard) {
                    bot.hand = bot.hand.filter(c => c !== marketCard);
                    generalMarketState.playersWhoPlayed.push(botIndex);
                    await animateCardPlayFromComputer(marketCard, botIndex);
                    discardPile.push(marketCard);
                    renderGame();
                }

                generalMarketState.respondedMask[botIndex] = true;
                
                if (gameMode === 'multiplayer') {
                    await updateServerGameState({
                        discardPile,
                        currentPlayerIndex,
                        activeStack,
                        whotRequest,
                        holdOnActive,
                        turnsToSkip,
                        generalMarketState,
                        eliminatedPlayers
                    });
                }
                
                checkIfMarketIsOver();
            }, 1000 + Math.random() * 500);
        }

        function checkIfMarketIsOver() {
            if (!generalMarketState.active) return;
            
            // Check only non-eliminated players
            const activePlayers = players.filter((_, i) => !eliminatedPlayers.includes(i));
            const allActiveResponded = activePlayers.every((player, index) => {
                const realIndex = players.findIndex(p => p.id === player.id);
                return generalMarketState.respondedMask[realIndex] === true;
            });
            
            if (allActiveResponded) {
                resolveGeneralMarket();
            }
        }

        async function resolveGeneralMarket() {
            const penaltyCount = generalMarketState.playersWhoPlayed.length;
            for (let i = 0; i < players.length; i++) {
                if (!generalMarketState.playersWhoPlayed.includes(i) && !eliminatedPlayers.includes(i)) {
                    for (let j = 0; j < penaltyCount; j++) {
                        await dealCardToPlayer(i);
                    }
                }
            }
            
            currentPlayerIndex = generalMarketState.initiator;
            generalMarketState = { active: false, initiator: null, respondedMask: [], playersWhoPlayed: [] };
            
            renderGame();
            
            if (gameMode === 'multiplayer') {
                await updateServerGameState({
                    discardPile,
                    currentPlayerIndex,
                    activeStack,
                    whotRequest,
                    holdOnActive,
                    turnsToSkip,
                    generalMarketState,
                    eliminatedPlayers
                });
            }
            
            if (!players[currentPlayerIndex].isHuman && !eliminatedPlayers.includes(currentPlayerIndex)) {
                setTimeout(() => botTurn(), 1000);
            }
        }

        // Shape selection functions
        function requestShapeFromPlayer() {
            shapeOptionsDiv.innerHTML = '';
            Object.keys(SHAPES_SVG).forEach(shape => {
                const optionDiv = document.createElement('div');
                optionDiv.className = `shape-option w-20 h-20 flex items-center justify-center rounded-full bg-gray-700 cursor-pointer text-white`;
                optionDiv.innerHTML = `<div class="w-12 h-12">${SHAPES_SVG[shape]}</div>`;
                optionDiv.addEventListener('click', () => selectShape(shape));
                shapeOptionsDiv.appendChild(optionDiv);
            });
            shapeModal.classList.remove('hidden');
            setTimeout(() => shapeModal.classList.remove('opacity-0'), 10);
        }

        async function selectShape(shape) {
            whotRequest = { shape };
            const topCard = discardPile[discardPile.length - 1];
            if (topCard && topCard.number === 20) {
                topCard.shape = shape;
            }
            shapeModal.classList.add('opacity-0');
            setTimeout(() => shapeModal.classList.add('hidden'), 300);
            renderGame();
            
            if (gameMode === 'multiplayer') {
                await updateServerGameState({
                    discardPile,
                    currentPlayerIndex,
                    activeStack,
                    whotRequest,
                    holdOnActive,
                    turnsToSkip,
                    generalMarketState,
                    eliminatedPlayers
                });
            }
            
            endTurn();
        }

        // Win condition
        function endGame(winner, isTournamentWin = false) {
            const winnerMessage = document.createElement('div');
            winnerMessage.className = "winner-message absolute inset-0 bg-black/70 flex items-center justify-center text-4xl font-bold z-50";
            
            if (isTournamentWin) {
                // In elimination mode, show tournament results
                const remainingPlayers = players.filter((_, i) => !eliminatedPlayers.includes(i));
                const tournamentWinner = remainingPlayers.length > 0 ? remainingPlayers[0] : null;
                winnerMessage.innerHTML = `
                    <div class="text-center">
                        <div class="text-6xl mb-4"></div>
                        <div>TOURNAMENT COMPLETE!</div>
                        ${tournamentWinner ? `<div class="text-2xl mt-4">${tournamentWinner.name.toUpperCase()} WINS THE TOURNAMENT!</div>` : ''}
                    </div>
                `;
            } else if (winner) {
                winnerMessage.textContent = `${winner.name.toUpperCase()} WINS!`;
            } else {
                winnerMessage.textContent = "GAME COMPLETE!";
            }
            
            document.getElementById('game-container').appendChild(winnerMessage);

            setTimeout(() => {
                gameContainer.classList.add('hidden');
                gameContainer.classList.remove('flex');
                
                // Reset to main menu
                eliminatedPlayers = [];
                if (gameMode === 'multiplayer' && currentGameId) {
                    // Clean up multiplayer game
                    if (isHost) {
                        window.firebase.remove(window.firebase.ref(window.firebase.database, `games/${currentGameId}`));
                    }
                    if (playersRef) window.firebase.off(playersRef);
                    if (gameStateRef) window.firebase.off(gameStateRef);
                    currentGameId = null;
                    playerId = null;
                    isHost = false;
                }
                mainMenu.classList.remove('hidden');
            }, 4000);
        }

        // Animation functions
        function animateCardDraw(targetElement) {
            return new Promise(resolve => {
                const startRect = drawPileDiv.getBoundingClientRect();
                const targetRect = targetElement.getBoundingClientRect();
                const animCard = document.createElement('div');
                animCard.className = 'card card-back drawing-card';
                animCard.innerHTML = createCardElement(null, false).innerHTML;
                document.body.appendChild(animCard);
                animCard.style.left = `${startRect.left}px`;
                animCard.style.top = `${startRect.top}px`;
                requestAnimationFrame(() => {
                    const endX = targetRect.left + (targetRect.width / 2) - (startRect.width / 2);
                    const endY = targetRect.top;
                    animCard.style.transform = `translate(${endX - startRect.left}px, ${endY - startRect.top}px)`;
                });
                setTimeout(() => {
                    animCard.remove();
                    resolve();
                }, 400);
            });
        }

        function animateCardPlayFromPosition(card, startRect, handName) {
             return new Promise(resolve => {
                if (!startRect) { 
                    const handDiv = handName === 'action' ? rightHandDiv : leftHandDiv;
                    const handRect = handDiv.getBoundingClientRect();
                    startRect = { left: handRect.left + handRect.width / 2 - 60, top: handRect.top };
                }
                
                const lastCardInPile = discardPileDiv.querySelector('.card:last-child');
                const targetRect = lastCardInPile ? lastCardInPile.getBoundingClientRect() : discardPileDiv.getBoundingClientRect();

                const animCard = document.createElement('div');
                animCard.className = 'card drawing-card';
                animCard.innerHTML = createCardElement(card, true).innerHTML;
                document.body.appendChild(animCard);
                animCard.style.left = `${startRect.left}px`;
                animCard.style.top = `${startRect.top}px`;
                animCard.style.width = '120px';
                animCard.style.height = '180px';
                
                requestAnimationFrame(() => {
                    const endX = targetRect.left;
                    const endY = targetRect.top;
                    animCard.style.transform = `translate(${endX - startRect.left}px, ${endY - startRect.top}px)`;
                });
                
                setTimeout(() => {
                    animCard.remove();
                    resolve();
                }, 400);
            });
        }

        function animateCardPlayFromComputer(card, playerIndex = currentPlayerIndex) {
            return new Promise(resolve => {
                const botProfiles = document.querySelectorAll('.computer-player-profile');
                const botProfile = Array.from(botProfiles).find(p => {
                    const nameDiv = p.querySelector('.font-semibold');
                    return nameDiv && nameDiv.textContent === players[playerIndex].name;
                });

                const startRect = botProfile ? botProfile.getBoundingClientRect() : { left: 0, top: 0, width: 120, height: 180 };
                
                const lastCardInPile = discardPileDiv.querySelector('.card:last-child');
                const targetRect = lastCardInPile ? lastCardInPile.getBoundingClientRect() : discardPileDiv.getBoundingClientRect();

                const animCard = document.createElement('div');
                animCard.className = 'card drawing-card';
                animCard.innerHTML = createCardElement(card, true).innerHTML;
                document.body.appendChild(animCard);
                animCard.style.left = `${startRect.left + startRect.width / 2 - 60}px`;
                animCard.style.top = `${startRect.top}px`;
                animCard.style.width = '120px';
                animCard.style.height = '180px';

                animCard.addEventListener('transitionend', () => {
                    animCard.remove();
                    resolve();
                }, { once: true });

                requestAnimationFrame(() => {
                    const endX = targetRect.left;
                    const endY = targetRect.top;
                    animCard.style.transform = `translate(${endX - (startRect.left + startRect.width / 2 - 60)}px, ${endY - startRect.top}px)`;
                });

                // Fallback in case transitionend doesn't fire
                setTimeout(() => {
                    if (animCard.parentNode) {
                        animCard.remove();
                        resolve();
                    }
                }, 500);
            });
        }

        // Event listeners and initialization
        drawPileDiv.addEventListener('click', handlePlayerDraw);
        
        // Game code input formatting
        document.getElementById('game-code-input').addEventListener('input', (e) => {
            let value = e.target.value.replace(/\D/g, '').slice(0, 6);
            e.target.value = value;
        });

        // Player name input validation
        document.getElementById('player-name-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('create-game-btn').click();
            }
        });

        document.getElementById('game-code-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('join-game-btn').click();
            }
        });
        
        // Initialize drag and drop when page loads
        window.onload = () => {
            setupDragAndDrop();
        };

        window.addEventListener('resize', renderGame);

        // Handle window close/refresh for multiplayer cleanup
        window.addEventListener('beforeunload', () => {
            if (gameMode === 'multiplayer' && currentGameId && playerId) {
                if (isHost) {
                    // Host leaving - delete game
                    navigator.sendBeacon(`https://whotwhotnigeria-default-rtdb.firebaseio.com/games/${currentGameId}.json`, JSON.stringify(null));
                } else {
                    // Player leaving - remove from players
                    navigator.sendBeacon(`https://whotwhotnigeria-default-rtdb.firebaseio.com/games/${currentGameId}/players/${playerId}.json`, JSON.stringify(null));
                }
            }
        });

        // Multiplayer game state sync handler
        function handleGameEnd(serverState) {
            if (serverState.winner) {
                const winner = players.find(p => p.id === serverState.winner.id);
                endGame(winner, serverState.isTournamentWin);
            }
        }

        // Additional helper functions for multiplayer synchronization
        async function syncPlayerHands(serverPlayers) {
            if (!serverPlayers) return;
            
            players.forEach(player => {
                const serverPlayer = serverPlayers[player.id];
                if (serverPlayer) {
                    if (player.isHuman) {
                        player.regularHand = serverPlayer.regularHand || [];
                        player.actionHand = serverPlayer.actionHand || [];
                    } else {
                        player.hand = serverPlayer.hand || [];
                    }
                }
            });
        }

        // Error handling for Firebase operations
        window.addEventListener('online', () => {
            if (gameMode === 'multiplayer' && currentGameId) {
                showToast('Connection restored', 'success');
            }
        });

        window.addEventListener('offline', () => {
            if (gameMode === 'multiplayer') {
                showToast('Connection lost - game may not sync properly', 'error');
            }
        });

        // Initialize the game
        console.log('Nigerian Whot Game - Multiplayer Edition Loaded');
        
        // Debug helper (remove in production)
        window.debugGame = {
            players: () => players,
            gameState: () => ({
                discardPile,
                drawPile: drawPile.length,
                currentPlayerIndex,
                activeStack,
                whotRequest,
                eliminatedPlayers
            }),
            firebase: () => window.firebase
        };
    </script>
</body>
</html>